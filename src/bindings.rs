/* automatically generated by rust-bindgen 0.71.1 */

#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
pub const NAM_UNKNOWN_EXPECTED_SAMPLE_RATE: f64 = -1.0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair {
    pub _address: u8,
}
pub type std_pair_first_type = u8;
pub type std_pair_second_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
pub type std_equal_to__Unnameable_first_argument = u8;
pub type std_equal_to__Unnameable_second_argument = u8;
pub type std_equal_to__Unnameable_result = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Simple_types {
    pub _address: u8,
}
pub type std__Simple_types_value_type = u8;
pub type std__Simple_types_size_type = u64;
pub type std__Simple_types_difference_type = u64;
pub type std__Simple_types_pointer = u8;
pub type std__Simple_types_const_pointer = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator__From_primary = u8;
pub type std_allocator_value_type = u8;
pub type std_allocator_size_type = u64;
pub type std_allocator_difference_type = u64;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string {
    pub _address: u8,
}
pub type std_basic_string__Alty = u8;
pub type std_basic_string__Alty_traits = u8;
pub type std_basic_string__Scary_val = u8;
pub type std_basic_string_traits_type = u8;
pub type std_basic_string_allocator_type = u8;
pub type std_basic_string_value_type = u8;
pub type std_basic_string_size_type = u8;
pub type std_basic_string_difference_type = u8;
pub type std_basic_string_pointer = u8;
pub type std_basic_string_const_pointer = u8;
pub type std_basic_string_reference = u8;
pub type std_basic_string_const_reference = u8;
pub type std_basic_string_iterator = u8;
pub type std_basic_string_const_iterator = u8;
pub type std_basic_string_reverse_iterator = u8;
pub type std_basic_string_const_reverse_iterator = u8;
pub type std_basic_string__Is_elem_cptr = u8;
pub type std_basic_string__Is_string_view_ish = u8;
pub const std_basic_string__Allocation_policy__At_least: std_basic_string__Allocation_policy = 0;
pub const std_basic_string__Allocation_policy__Exactly: std_basic_string__Allocation_policy = 0;
pub type std_basic_string__Allocation_policy = ::std::os::raw::c_int;
pub const std_basic_string__Construct_strategy__From_char: std_basic_string__Construct_strategy = 0;
pub const std_basic_string__Construct_strategy__From_ptr: std_basic_string__Construct_strategy = 0;
pub const std_basic_string__Construct_strategy__From_string: std_basic_string__Construct_strategy =
    0;
pub type std_basic_string__Construct_strategy = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string__Released_buffer {
    pub _address: u8,
}
pub type std_string = __BindgenOpaqueArray<u64, 4usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr {
    pub _address: u8,
}
pub type std_unique_ptr_pointer = u8;
pub type std_unique_ptr_element_type = u8;
pub type std_unique_ptr_deleter_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Vector_iterator {
    pub _address: u8,
}
pub type std__Vector_iterator__Mybase = u8;
pub type std__Vector_iterator_iterator_concept = u8;
pub type std__Vector_iterator_iterator_category = u8;
pub type std__Vector_iterator_value_type = u8;
pub type std__Vector_iterator_difference_type = u8;
pub type std__Vector_iterator_pointer = u8;
pub type std__Vector_iterator_reference = u8;
pub type std__Vector_iterator__Prevent_inheriting_unwrap = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Vec_iter_types {
    pub _address: u8,
}
pub type std__Vec_iter_types_value_type = u8;
pub type std__Vec_iter_types_size_type = u8;
pub type std__Vec_iter_types_difference_type = u8;
pub type std__Vec_iter_types_pointer = u8;
pub type std__Vec_iter_types_const_pointer = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Vector_val {
    pub _address: u8,
}
pub type std__Vector_val_value_type = u8;
pub type std__Vector_val_size_type = u8;
pub type std__Vector_val_difference_type = u8;
pub type std__Vector_val_pointer = u8;
pub type std__Vector_val_const_pointer = u8;
pub type std__Vector_val_reference = u8;
pub type std__Vector_val_const_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Alty = u8;
pub type std_vector__Alty_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_allocator_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_size_type = u8;
pub type std_vector_difference_type = u8;
pub type std_vector__Scary_val = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector__Reallocation_guard {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector__Simple_reallocation_guard {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector__Vaporization_guard {
    pub _address: u8,
}
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub const std_vector__Reallocation_policy__At_least: std_vector__Reallocation_policy = 0;
pub const std_vector__Reallocation_policy__Exactly: std_vector__Reallocation_policy = 0;
pub type std_vector__Reallocation_policy = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_filesystem_path {
    pub _bindgen_opaque_blob: [u64; 4usize],
}
pub type std_filesystem_path_value_type = u16;
pub type std_filesystem_path_string_type = __BindgenOpaqueArray<u64, 4usize>;
pub const std_filesystem_path_format_auto_format: std_filesystem_path_format = 0;
pub const std_filesystem_path_format_native_format: std_filesystem_path_format = 1;
pub const std_filesystem_path_format_generic_format: std_filesystem_path_format = 2;
pub type std_filesystem_path_format = ::std::os::raw::c_int;
pub type std_filesystem_path_iterator = __BindgenOpaqueArray<u64, 6usize>;
pub type std_filesystem_path_const_iterator = __BindgenOpaqueArray<u64, 6usize>;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_filesystem_path"][::std::mem::size_of::<std_filesystem_path>() - 32usize];
    ["Alignment of std_filesystem_path"][::std::mem::align_of::<std_filesystem_path>() - 8usize];
};
pub const std_filesystem_path_preferred_separator: u16 = 92;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unordered_map {
    pub _address: u8,
}
pub type std_unordered_map__Mytraits = u8;
pub type std_unordered_map__Mybase = u8;
pub type std_unordered_map__Alnode = u8;
pub type std_unordered_map__Alnode_traits = u8;
pub type std_unordered_map__Nodeptr = u8;
pub type std_unordered_map__Key_compare = u8;
pub type std_unordered_map_hasher = u8;
pub type std_unordered_map_key_type = u8;
pub type std_unordered_map_mapped_type = u8;
pub type std_unordered_map_key_equal = u8;
pub type std_unordered_map_value_type = u8;
pub type std_unordered_map_allocator_type = u8;
pub type std_unordered_map_size_type = u8;
pub type std_unordered_map_difference_type = u8;
pub type std_unordered_map_pointer = u8;
pub type std_unordered_map_const_pointer = u8;
pub type std_unordered_map_reference = u8;
pub type std_unordered_map_const_reference = u8;
pub type std_unordered_map_iterator = u8;
pub type std_unordered_map_const_iterator = u8;
pub type std_unordered_map_local_iterator = u8;
pub type std_unordered_map_const_local_iterator = u8;
pub type std_unordered_map_insert_return_type = u8;
#[doc = " \\brief Base class typedef.\n \\sa PlainObjectBase"]
pub type Eigen_Matrix_Base = u8;
pub const Eigen_Matrix_Options: Eigen_Matrix__bindgen_ty_1 = 0;
pub type Eigen_Matrix__bindgen_ty_1 = ::std::os::raw::c_int;
pub type Eigen_Matrix_Scalar = u8;
pub type Eigen_Matrix_RealScalar = u8;
pub type Eigen_Matrix_CoeffReturnType = u8;
pub type Eigen_Matrix_Nested = u8;
pub type Eigen_Matrix_StorageKind = u8;
pub type Eigen_Matrix_StorageIndex = u8;
pub const Eigen_Matrix_CompileTimeTraits_RowsAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_ColsAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_Flags: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_SizeAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_MaxSizeAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_IsVectorAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub type Eigen_Matrix_CompileTimeTraits = ::std::os::raw::c_int;
pub type Eigen_Matrix_PacketScalar = u8;
pub type Eigen_Matrix_PlainObject = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam Scalar_ Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam Rows_ Number of rows, or \\b Dynamic\n \\tparam Cols_ Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam Options_ A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam MaxRows_ Maximum number of rows. Defaults to \\a Rows_ (\\ref maxrows \"note\").\n \\tparam MaxCols_ Maximum number of columns. Defaults to \\a Cols_ (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows MaxRows_ and MaxCols_:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case MaxRows_ and MaxCols_\n are the dimensions of the original matrix, while Rows_ and Cols_ are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_MatrixXf = __BindgenOpaqueArray<u64, 3usize>;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam Scalar_ Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam Rows_ Number of rows, or \\b Dynamic\n \\tparam Cols_ Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam Options_ A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam MaxRows_ Maximum number of rows. Defaults to \\a Rows_ (\\ref maxrows \"note\").\n \\tparam MaxCols_ Maximum number of columns. Defaults to \\a Cols_ (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows MaxRows_ and MaxCols_:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case MaxRows_ and MaxCols_\n are the dimensions of the original matrix, while Rows_ and Cols_ are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_VectorXf = __BindgenOpaqueArray<u64, 2usize>;
pub type Eigen_Block_Impl = u8;
pub type Eigen_Block_Base = u8;
pub type Eigen_Block_Scalar = u8;
pub type Eigen_Block_RealScalar = u8;
pub type Eigen_Block_CoeffReturnType = u8;
pub type Eigen_Block_Nested = u8;
pub type Eigen_Block_StorageKind = u8;
pub type Eigen_Block_StorageIndex = u8;
pub const Eigen_Block_CompileTimeTraits_RowsAtCompileTime: Eigen_Block_CompileTimeTraits = 0;
pub const Eigen_Block_CompileTimeTraits_ColsAtCompileTime: Eigen_Block_CompileTimeTraits = 0;
pub const Eigen_Block_CompileTimeTraits_Flags: Eigen_Block_CompileTimeTraits = 0;
pub const Eigen_Block_CompileTimeTraits_SizeAtCompileTime: Eigen_Block_CompileTimeTraits = 0;
pub const Eigen_Block_CompileTimeTraits_MaxSizeAtCompileTime: Eigen_Block_CompileTimeTraits = 0;
pub const Eigen_Block_CompileTimeTraits_IsVectorAtCompileTime: Eigen_Block_CompileTimeTraits = 0;
pub type Eigen_Block_CompileTimeTraits = ::std::os::raw::c_int;
pub type Eigen_Block_NestedExpression = u8;
#[repr(C)]
pub struct nam_activations_Activation__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nam_activations_Activation {
    pub vtable_: *const nam_activations_Activation__bindgen_vtable,
}
unsafe extern "C" {
    #[link_name = "\u{1}?using_fast_tanh@Activation@activations@nam@@2_NA"]
    pub static mut nam_activations_Activation_using_fast_tanh: bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}?_activations@Activation@activations@nam@@1V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVActivation@activations@nam@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVActivation@activations@nam@@@std@@@2@@std@@A"]
    pub static mut nam_activations_Activation__activations: u8;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_activations_Activation"]
        [::std::mem::size_of::<nam_activations_Activation>() - 8usize];
    ["Alignment of nam_activations_Activation"]
        [::std::mem::align_of::<nam_activations_Activation>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?get_activation@Activation@activations@nam@@SAPEAV123@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn nam_activations_Activation_get_activation(
        name: std_string,
    ) -> *mut nam_activations_Activation;
}
unsafe extern "C" {
    #[link_name = "\u{1}?enable_fast_tanh@Activation@activations@nam@@SAXXZ"]
    pub fn nam_activations_Activation_enable_fast_tanh();
}
unsafe extern "C" {
    #[link_name = "\u{1}?disable_fast_tanh@Activation@activations@nam@@SAXXZ"]
    pub fn nam_activations_Activation_disable_fast_tanh();
}
impl nam_activations_Activation {
    #[inline]
    pub unsafe fn get_activation(name: std_string) -> *mut nam_activations_Activation {
        nam_activations_Activation_get_activation(name)
    }
    #[inline]
    pub unsafe fn enable_fast_tanh() {
        nam_activations_Activation_enable_fast_tanh()
    }
    #[inline]
    pub unsafe fn disable_fast_tanh() {
        nam_activations_Activation_disable_fast_tanh()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_activations_ActivationTanh {
    pub _base: nam_activations_Activation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_activations_ActivationTanh"]
        [::std::mem::size_of::<nam_activations_ActivationTanh>() - 8usize];
    ["Alignment of nam_activations_ActivationTanh"]
        [::std::mem::align_of::<nam_activations_ActivationTanh>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct nam_activations_ActivationHardTanh {
    pub _base: nam_activations_Activation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_activations_ActivationHardTanh"]
        [::std::mem::size_of::<nam_activations_ActivationHardTanh>() - 8usize];
    ["Alignment of nam_activations_ActivationHardTanh"]
        [::std::mem::align_of::<nam_activations_ActivationHardTanh>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct nam_activations_ActivationFastTanh {
    pub _base: nam_activations_Activation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_activations_ActivationFastTanh"]
        [::std::mem::size_of::<nam_activations_ActivationFastTanh>() - 8usize];
    ["Alignment of nam_activations_ActivationFastTanh"]
        [::std::mem::align_of::<nam_activations_ActivationFastTanh>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct nam_activations_ActivationReLU {
    pub _base: nam_activations_Activation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_activations_ActivationReLU"]
        [::std::mem::size_of::<nam_activations_ActivationReLU>() - 8usize];
    ["Alignment of nam_activations_ActivationReLU"]
        [::std::mem::align_of::<nam_activations_ActivationReLU>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct nam_activations_ActivationLeakyReLU {
    pub _base: nam_activations_Activation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_activations_ActivationLeakyReLU"]
        [::std::mem::size_of::<nam_activations_ActivationLeakyReLU>() - 8usize];
    ["Alignment of nam_activations_ActivationLeakyReLU"]
        [::std::mem::align_of::<nam_activations_ActivationLeakyReLU>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct nam_activations_ActivationSigmoid {
    pub _base: nam_activations_Activation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_activations_ActivationSigmoid"]
        [::std::mem::size_of::<nam_activations_ActivationSigmoid>() - 8usize];
    ["Alignment of nam_activations_ActivationSigmoid"]
        [::std::mem::align_of::<nam_activations_ActivationSigmoid>() - 8usize];
};
pub const nam_EArchitectures_kLinear: nam_EArchitectures = 0;
pub const nam_EArchitectures_kConvNet: nam_EArchitectures = 1;
pub const nam_EArchitectures_kLSTM: nam_EArchitectures = 2;
pub const nam_EArchitectures_kCatLSTM: nam_EArchitectures = 3;
pub const nam_EArchitectures_kWaveNet: nam_EArchitectures = 4;
pub const nam_EArchitectures_kCatWaveNet: nam_EArchitectures = 5;
pub const nam_EArchitectures_kNumModels: nam_EArchitectures = 6;
pub type nam_EArchitectures = ::std::os::raw::c_int;
#[repr(C)]
pub struct nam_DSP__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nam_DSP {
    pub vtable_: *const nam_DSP__bindgen_vtable,
    mHasLoudness: bool,
    mLoudness: f64,
    mExpectedSampleRate: f64,
    mHaveExternalSampleRate: bool,
    mExternalSampleRate: f64,
    mMaxBufferSize: ::std::os::raw::c_int,
    mInputLevel: nam_DSP_Level,
    mOutputLevel: nam_DSP_Level,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nam_DSP_Level {
    pub haveLevel: bool,
    pub level: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_DSP_Level"][::std::mem::size_of::<nam_DSP_Level>() - 8usize];
    ["Alignment of nam_DSP_Level"][::std::mem::align_of::<nam_DSP_Level>() - 4usize];
    ["Offset of field: nam_DSP_Level::haveLevel"]
        [::std::mem::offset_of!(nam_DSP_Level, haveLevel) - 0usize];
    ["Offset of field: nam_DSP_Level::level"]
        [::std::mem::offset_of!(nam_DSP_Level, level) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_DSP"][::std::mem::size_of::<nam_DSP>() - 72usize];
    ["Alignment of nam_DSP"][::std::mem::align_of::<nam_DSP>() - 8usize];
    ["Offset of field: nam_DSP::mHasLoudness"]
        [::std::mem::offset_of!(nam_DSP, mHasLoudness) - 8usize];
    ["Offset of field: nam_DSP::mLoudness"][::std::mem::offset_of!(nam_DSP, mLoudness) - 16usize];
    ["Offset of field: nam_DSP::mExpectedSampleRate"]
        [::std::mem::offset_of!(nam_DSP, mExpectedSampleRate) - 24usize];
    ["Offset of field: nam_DSP::mHaveExternalSampleRate"]
        [::std::mem::offset_of!(nam_DSP, mHaveExternalSampleRate) - 32usize];
    ["Offset of field: nam_DSP::mExternalSampleRate"]
        [::std::mem::offset_of!(nam_DSP, mExternalSampleRate) - 40usize];
    ["Offset of field: nam_DSP::mMaxBufferSize"]
        [::std::mem::offset_of!(nam_DSP, mMaxBufferSize) - 48usize];
    ["Offset of field: nam_DSP::mInputLevel"]
        [::std::mem::offset_of!(nam_DSP, mInputLevel) - 52usize];
    ["Offset of field: nam_DSP::mOutputLevel"]
        [::std::mem::offset_of!(nam_DSP, mOutputLevel) - 60usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?GetLoudness@DSP@nam@@QEBANXZ"]
    pub fn nam_DSP_GetLoudness(this: *const nam_DSP) -> f64;
}
unsafe extern "C" {
    #[link_name = "\u{1}?SetLoudness@DSP@nam@@QEAAXN@Z"]
    pub fn nam_DSP_SetLoudness(this: *mut nam_DSP, loudness: f64);
}
unsafe extern "C" {
    #[link_name = "\u{1}??0DSP@nam@@QEAA@N@Z"]
    pub fn nam_DSP_DSP(this: *mut nam_DSP, expected_sample_rate: f64);
}
impl nam_DSP {
    #[inline]
    pub unsafe fn GetLoudness(&self) -> f64 {
        nam_DSP_GetLoudness(self)
    }
    #[inline]
    pub unsafe fn SetLoudness(&mut self, loudness: f64) {
        nam_DSP_SetLoudness(self, loudness)
    }
    #[inline]
    pub unsafe fn new(expected_sample_rate: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_DSP_DSP(__bindgen_tmp.as_mut_ptr(), expected_sample_rate);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}?prewarm@DSP@nam@@UEAAXXZ"]
    pub fn nam_DSP_prewarm(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "\u{1}?process@DSP@nam@@UEAAXPEAN0H@Z"]
    pub fn nam_DSP_process(
        this: *mut ::std::os::raw::c_void,
        input: *mut f64,
        output: *mut f64,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?Reset@DSP@nam@@UEAAXNH@Z"]
    pub fn nam_DSP_Reset(
        this: *mut ::std::os::raw::c_void,
        sampleRate: f64,
        maxBufferSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?SetMaxBufferSize@DSP@nam@@MEAAXH@Z"]
    pub fn nam_DSP_SetMaxBufferSize(
        this: *mut ::std::os::raw::c_void,
        maxBufferSize: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct nam_Buffer {
    pub _bindgen_opaque_blob: [u64; 17usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_Buffer"][::std::mem::size_of::<nam_Buffer>() - 136usize];
    ["Alignment of nam_Buffer"][::std::mem::align_of::<nam_Buffer>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?_advance_input_buffer_@Buffer@nam@@IEAAXH@Z"]
    pub fn nam_Buffer__advance_input_buffer_(
        this: *mut nam_Buffer,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?_set_receptive_field@Buffer@nam@@IEAAXHH@Z"]
    pub fn nam_Buffer__set_receptive_field(
        this: *mut nam_Buffer,
        new_receptive_field: ::std::os::raw::c_int,
        input_buffer_size: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?_set_receptive_field@Buffer@nam@@IEAAXH@Z"]
    pub fn nam_Buffer__set_receptive_field1(
        this: *mut nam_Buffer,
        new_receptive_field: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?_reset_input_buffer@Buffer@nam@@IEAAXXZ"]
    pub fn nam_Buffer__reset_input_buffer(this: *mut nam_Buffer);
}
unsafe extern "C" {
    #[link_name = "\u{1}??0Buffer@nam@@QEAA@HN@Z"]
    pub fn nam_Buffer_Buffer(
        this: *mut nam_Buffer,
        receptive_field: ::std::os::raw::c_int,
        expected_sample_rate: f64,
    );
}
impl nam_Buffer {
    #[inline]
    pub unsafe fn _advance_input_buffer_(&mut self, num_frames: ::std::os::raw::c_int) {
        nam_Buffer__advance_input_buffer_(self, num_frames)
    }
    #[inline]
    pub unsafe fn _set_receptive_field(
        &mut self,
        new_receptive_field: ::std::os::raw::c_int,
        input_buffer_size: ::std::os::raw::c_int,
    ) {
        nam_Buffer__set_receptive_field(self, new_receptive_field, input_buffer_size)
    }
    #[inline]
    pub unsafe fn _set_receptive_field1(&mut self, new_receptive_field: ::std::os::raw::c_int) {
        nam_Buffer__set_receptive_field1(self, new_receptive_field)
    }
    #[inline]
    pub unsafe fn _reset_input_buffer(&mut self) {
        nam_Buffer__reset_input_buffer(self)
    }
    #[inline]
    pub unsafe fn new(receptive_field: ::std::os::raw::c_int, expected_sample_rate: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_Buffer_Buffer(
            __bindgen_tmp.as_mut_ptr(),
            receptive_field,
            expected_sample_rate,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}?_update_buffers_@Buffer@nam@@MEAAXPEANH@Z"]
    pub fn nam_Buffer__update_buffers_(
        this: *mut ::std::os::raw::c_void,
        input: *mut f64,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?_rewind_buffers_@Buffer@nam@@MEAAXXZ"]
    pub fn nam_Buffer__rewind_buffers_(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nam_Linear {
    pub _base: nam_Buffer,
    _weight: Eigen_VectorXf,
    _bias: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_Linear"][::std::mem::size_of::<nam_Linear>() - 160usize];
    ["Alignment of nam_Linear"][::std::mem::align_of::<nam_Linear>() - 8usize];
    ["Offset of field: nam_Linear::_weight"]
        [::std::mem::offset_of!(nam_Linear, _weight) - 136usize];
    ["Offset of field: nam_Linear::_bias"][::std::mem::offset_of!(nam_Linear, _bias) - 152usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}??0Linear@nam@@QEAA@H_NAEBV?$vector@MV?$allocator@M@std@@@std@@N@Z"]
    pub fn nam_Linear_Linear(
        this: *mut nam_Linear,
        receptive_field: ::std::os::raw::c_int,
        _bias: bool,
        weights: *const __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    );
}
impl nam_Linear {
    #[inline]
    pub unsafe fn new(
        receptive_field: ::std::os::raw::c_int,
        _bias: bool,
        weights: *const __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_Linear_Linear(
            __bindgen_tmp.as_mut_ptr(),
            receptive_field,
            _bias,
            weights,
            expected_sample_rate,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}?process@Linear@nam@@UEAAXPEAN0H@Z"]
    pub fn nam_Linear_process(
        this: *mut ::std::os::raw::c_void,
        input: *mut f64,
        output: *mut f64,
        num_frames: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_Conv1D {
    _weight: __BindgenOpaqueArray<u64, 3usize>,
    _bias: Eigen_VectorXf,
    _dilation: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_Conv1D"][::std::mem::size_of::<nam_Conv1D>() - 48usize];
    ["Alignment of nam_Conv1D"][::std::mem::align_of::<nam_Conv1D>() - 8usize];
    ["Offset of field: nam_Conv1D::_weight"][::std::mem::offset_of!(nam_Conv1D, _weight) - 0usize];
    ["Offset of field: nam_Conv1D::_bias"][::std::mem::offset_of!(nam_Conv1D, _bias) - 24usize];
    ["Offset of field: nam_Conv1D::_dilation"]
        [::std::mem::offset_of!(nam_Conv1D, _dilation) - 40usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?set_weights_@Conv1D@nam@@QEAAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@Z"]
    pub fn nam_Conv1D_set_weights_(this: *mut nam_Conv1D, weights: *mut u8);
}
unsafe extern "C" {
    #[link_name = "\u{1}?set_size_@Conv1D@nam@@QEAAXHHH_NH@Z"]
    pub fn nam_Conv1D_set_size_(
        this: *mut nam_Conv1D,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        do_bias: bool,
        _dilation: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?set_size_and_weights_@Conv1D@nam@@QEAAXHHHH_NAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@Z"]
    pub fn nam_Conv1D_set_size_and_weights_(
        this: *mut nam_Conv1D,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        _dilation: ::std::os::raw::c_int,
        do_bias: bool,
        weights: *mut u8,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?process_@Conv1D@nam@@QEBAXAEBV?$Matrix@M$0?0$0?0$0A@$0?0$0?0@Eigen@@AEAV34@JJJ@Z"]
    pub fn nam_Conv1D_process_(
        this: *const nam_Conv1D,
        input: *const Eigen_MatrixXf,
        output: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        ncols: ::std::os::raw::c_long,
        j_start: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?get_num_weights@Conv1D@nam@@QEBAJXZ"]
    pub fn nam_Conv1D_get_num_weights(this: *const nam_Conv1D) -> ::std::os::raw::c_long;
}
impl nam_Conv1D {
    #[inline]
    pub unsafe fn set_weights_(&mut self, weights: *mut u8) {
        nam_Conv1D_set_weights_(self, weights)
    }
    #[inline]
    pub unsafe fn set_size_(
        &mut self,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        do_bias: bool,
        _dilation: ::std::os::raw::c_int,
    ) {
        nam_Conv1D_set_size_(
            self,
            in_channels,
            out_channels,
            kernel_size,
            do_bias,
            _dilation,
        )
    }
    #[inline]
    pub unsafe fn set_size_and_weights_(
        &mut self,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        _dilation: ::std::os::raw::c_int,
        do_bias: bool,
        weights: *mut u8,
    ) {
        nam_Conv1D_set_size_and_weights_(
            self,
            in_channels,
            out_channels,
            kernel_size,
            _dilation,
            do_bias,
            weights,
        )
    }
    #[inline]
    pub unsafe fn process_(
        &self,
        input: *const Eigen_MatrixXf,
        output: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        ncols: ::std::os::raw::c_long,
        j_start: ::std::os::raw::c_long,
    ) {
        nam_Conv1D_process_(self, input, output, i_start, ncols, j_start)
    }
    #[inline]
    pub unsafe fn get_num_weights(&self) -> ::std::os::raw::c_long {
        nam_Conv1D_get_num_weights(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nam_Conv1x1 {
    _weight: Eigen_MatrixXf,
    _bias: Eigen_VectorXf,
    _output: Eigen_MatrixXf,
    _do_bias: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_Conv1x1"][::std::mem::size_of::<nam_Conv1x1>() - 72usize];
    ["Alignment of nam_Conv1x1"][::std::mem::align_of::<nam_Conv1x1>() - 8usize];
    ["Offset of field: nam_Conv1x1::_weight"]
        [::std::mem::offset_of!(nam_Conv1x1, _weight) - 0usize];
    ["Offset of field: nam_Conv1x1::_bias"][::std::mem::offset_of!(nam_Conv1x1, _bias) - 24usize];
    ["Offset of field: nam_Conv1x1::_output"]
        [::std::mem::offset_of!(nam_Conv1x1, _output) - 40usize];
    ["Offset of field: nam_Conv1x1::_do_bias"]
        [::std::mem::offset_of!(nam_Conv1x1, _do_bias) - 64usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?GetOutput@Conv1x1@nam@@QEAA?AV?$Block@V?$Matrix@M$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@H@Z"]
    pub fn nam_Conv1x1_GetOutput(
        this: *mut nam_Conv1x1,
        num_frames: ::std::os::raw::c_int,
    ) -> __BindgenOpaqueArray<u64, 7usize>;
}
unsafe extern "C" {
    #[link_name = "\u{1}?SetMaxBufferSize@Conv1x1@nam@@QEAAXH@Z"]
    pub fn nam_Conv1x1_SetMaxBufferSize(
        this: *mut nam_Conv1x1,
        maxBufferSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?set_weights_@Conv1x1@nam@@QEAAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@Z"]
    pub fn nam_Conv1x1_set_weights_(this: *mut nam_Conv1x1, weights: *mut u8);
}
unsafe extern "C" {
    #[link_name = "\u{1}?process@Conv1x1@nam@@QEBA?AV?$Matrix@M$0?0$0?0$0A@$0?0$0?0@Eigen@@AEBV34@H@Z"]
    pub fn nam_Conv1x1_process(
        this: *const nam_Conv1x1,
        input: *const Eigen_MatrixXf,
        num_frames: ::std::os::raw::c_int,
    ) -> Eigen_MatrixXf;
}
unsafe extern "C" {
    #[link_name = "\u{1}?process_@Conv1x1@nam@@QEAAXAEBV?$Matrix@M$0?0$0?0$0A@$0?0$0?0@Eigen@@H@Z"]
    pub fn nam_Conv1x1_process_(
        this: *mut nam_Conv1x1,
        input: *const Eigen_MatrixXf,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}??0Conv1x1@nam@@QEAA@HH_N@Z"]
    pub fn nam_Conv1x1_Conv1x1(
        this: *mut nam_Conv1x1,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        _bias: bool,
    );
}
impl nam_Conv1x1 {
    #[inline]
    pub unsafe fn GetOutput(
        &mut self,
        num_frames: ::std::os::raw::c_int,
    ) -> __BindgenOpaqueArray<u64, 7usize> {
        nam_Conv1x1_GetOutput(self, num_frames)
    }
    #[inline]
    pub unsafe fn SetMaxBufferSize(&mut self, maxBufferSize: ::std::os::raw::c_int) {
        nam_Conv1x1_SetMaxBufferSize(self, maxBufferSize)
    }
    #[inline]
    pub unsafe fn set_weights_(&mut self, weights: *mut u8) {
        nam_Conv1x1_set_weights_(self, weights)
    }
    #[inline]
    pub unsafe fn process(
        &self,
        input: *const Eigen_MatrixXf,
        num_frames: ::std::os::raw::c_int,
    ) -> Eigen_MatrixXf {
        nam_Conv1x1_process(self, input, num_frames)
    }
    #[inline]
    pub unsafe fn process_(
        &mut self,
        input: *const Eigen_MatrixXf,
        num_frames: ::std::os::raw::c_int,
    ) {
        nam_Conv1x1_process_(self, input, num_frames)
    }
    #[inline]
    pub unsafe fn new(
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        _bias: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_Conv1x1_Conv1x1(__bindgen_tmp.as_mut_ptr(), in_channels, out_channels, _bias);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_dspData {
    pub version: std_string,
    pub architecture: std_string,
    pub config: nlohmann_json,
    pub metadata: nlohmann_json,
    pub weights: __BindgenOpaqueArray<u64, 3usize>,
    pub expected_sample_rate: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_dspData"][::std::mem::size_of::<nam_dspData>() - 128usize];
    ["Alignment of nam_dspData"][::std::mem::align_of::<nam_dspData>() - 8usize];
    ["Offset of field: nam_dspData::version"]
        [::std::mem::offset_of!(nam_dspData, version) - 0usize];
    ["Offset of field: nam_dspData::architecture"]
        [::std::mem::offset_of!(nam_dspData, architecture) - 32usize];
    ["Offset of field: nam_dspData::config"][::std::mem::offset_of!(nam_dspData, config) - 64usize];
    ["Offset of field: nam_dspData::metadata"]
        [::std::mem::offset_of!(nam_dspData, metadata) - 80usize];
    ["Offset of field: nam_dspData::weights"]
        [::std::mem::offset_of!(nam_dspData, weights) - 96usize];
    ["Offset of field: nam_dspData::expected_sample_rate"]
        [::std::mem::offset_of!(nam_dspData, expected_sample_rate) - 120usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?verify_config_version@nam@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn nam_verify_config_version(version: std_string);
}
unsafe extern "C" {
    #[link_name = "\u{1}?get_dsp@nam@@YA?AV?$unique_ptr@VDSP@nam@@U?$default_delete@VDSP@nam@@@std@@@std@@Vpath@filesystem@3@@Z"]
    pub fn nam_get_dsp(model_file: std_filesystem_path) -> u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}?get_dsp@nam@@YA?AV?$unique_ptr@VDSP@nam@@U?$default_delete@VDSP@nam@@@std@@@std@@Vpath@filesystem@3@AEAUdspData@1@@Z"]
    pub fn nam_get_dsp1(model_file: std_filesystem_path, returnedConfig: *mut nam_dspData) -> u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}?get_dsp@nam@@YA?AV?$unique_ptr@VDSP@nam@@U?$default_delete@VDSP@nam@@@std@@@std@@AEAUdspData@1@@Z"]
    pub fn nam_get_dsp2(conf: *mut nam_dspData) -> u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}?get_dsp_legacy@nam@@YA?AV?$unique_ptr@VDSP@nam@@U?$default_delete@VDSP@nam@@@std@@@std@@Vpath@filesystem@3@@Z"]
    pub fn nam_get_dsp_legacy(dirname: std_filesystem_path) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nam_convnet_BatchNorm {
    scale: Eigen_VectorXf,
    loc: Eigen_VectorXf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_convnet_BatchNorm"][::std::mem::size_of::<nam_convnet_BatchNorm>() - 32usize];
    ["Alignment of nam_convnet_BatchNorm"]
        [::std::mem::align_of::<nam_convnet_BatchNorm>() - 8usize];
    ["Offset of field: nam_convnet_BatchNorm::scale"]
        [::std::mem::offset_of!(nam_convnet_BatchNorm, scale) - 0usize];
    ["Offset of field: nam_convnet_BatchNorm::loc"]
        [::std::mem::offset_of!(nam_convnet_BatchNorm, loc) - 16usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?process_@BatchNorm@convnet@nam@@QEBAXAEAV?$Matrix@M$0?0$0?0$0A@$0?0$0?0@Eigen@@JJ@Z"]
    pub fn nam_convnet_BatchNorm_process_(
        this: *const nam_convnet_BatchNorm,
        input: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        i_end: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}??0BatchNorm@convnet@nam@@QEAA@HAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@Z"]
    pub fn nam_convnet_BatchNorm_BatchNorm(
        this: *mut nam_convnet_BatchNorm,
        dim: ::std::os::raw::c_int,
        weights: *mut u8,
    );
}
impl nam_convnet_BatchNorm {
    #[inline]
    pub unsafe fn process_(
        &self,
        input: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        i_end: ::std::os::raw::c_long,
    ) {
        nam_convnet_BatchNorm_process_(self, input, i_start, i_end)
    }
    #[inline]
    pub unsafe fn new(dim: ::std::os::raw::c_int, weights: *mut u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_convnet_BatchNorm_BatchNorm(__bindgen_tmp.as_mut_ptr(), dim, weights);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_convnet_ConvNetBlock {
    pub conv: nam_Conv1D,
    batchnorm: nam_convnet_BatchNorm,
    _batchnorm: bool,
    activation: *mut nam_activations_Activation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_convnet_ConvNetBlock"]
        [::std::mem::size_of::<nam_convnet_ConvNetBlock>() - 96usize];
    ["Alignment of nam_convnet_ConvNetBlock"]
        [::std::mem::align_of::<nam_convnet_ConvNetBlock>() - 8usize];
    ["Offset of field: nam_convnet_ConvNetBlock::conv"]
        [::std::mem::offset_of!(nam_convnet_ConvNetBlock, conv) - 0usize];
    ["Offset of field: nam_convnet_ConvNetBlock::batchnorm"]
        [::std::mem::offset_of!(nam_convnet_ConvNetBlock, batchnorm) - 48usize];
    ["Offset of field: nam_convnet_ConvNetBlock::_batchnorm"]
        [::std::mem::offset_of!(nam_convnet_ConvNetBlock, _batchnorm) - 80usize];
    ["Offset of field: nam_convnet_ConvNetBlock::activation"]
        [::std::mem::offset_of!(nam_convnet_ConvNetBlock, activation) - 88usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?set_weights_@ConvNetBlock@convnet@nam@@QEAAXHHH_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@5@@Z"]
    pub fn nam_convnet_ConvNetBlock_set_weights_(
        this: *mut nam_convnet_ConvNetBlock,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        _dilation: ::std::os::raw::c_int,
        batchnorm: bool,
        activation: std_string,
        weights: *mut u8,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?process_@ConvNetBlock@convnet@nam@@QEBAXAEBV?$Matrix@M$0?0$0?0$0A@$0?0$0?0@Eigen@@AEAV45@JJ@Z"]
    pub fn nam_convnet_ConvNetBlock_process_(
        this: *const nam_convnet_ConvNetBlock,
        input: *const Eigen_MatrixXf,
        output: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        i_end: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?get_out_channels@ConvNetBlock@convnet@nam@@QEBAJXZ"]
    pub fn nam_convnet_ConvNetBlock_get_out_channels(
        this: *const nam_convnet_ConvNetBlock,
    ) -> ::std::os::raw::c_long;
}
impl nam_convnet_ConvNetBlock {
    #[inline]
    pub unsafe fn set_weights_(
        &mut self,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        _dilation: ::std::os::raw::c_int,
        batchnorm: bool,
        activation: std_string,
        weights: *mut u8,
    ) {
        nam_convnet_ConvNetBlock_set_weights_(
            self,
            in_channels,
            out_channels,
            _dilation,
            batchnorm,
            activation,
            weights,
        )
    }
    #[inline]
    pub unsafe fn process_(
        &self,
        input: *const Eigen_MatrixXf,
        output: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        i_end: ::std::os::raw::c_long,
    ) {
        nam_convnet_ConvNetBlock_process_(self, input, output, i_start, i_end)
    }
    #[inline]
    pub unsafe fn get_out_channels(&self) -> ::std::os::raw::c_long {
        nam_convnet_ConvNetBlock_get_out_channels(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nam_convnet__Head {
    _weight: Eigen_VectorXf,
    _bias: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_convnet__Head"][::std::mem::size_of::<nam_convnet__Head>() - 24usize];
    ["Alignment of nam_convnet__Head"][::std::mem::align_of::<nam_convnet__Head>() - 8usize];
    ["Offset of field: nam_convnet__Head::_weight"]
        [::std::mem::offset_of!(nam_convnet__Head, _weight) - 0usize];
    ["Offset of field: nam_convnet__Head::_bias"]
        [::std::mem::offset_of!(nam_convnet__Head, _bias) - 16usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?process_@_Head@convnet@nam@@QEBAXAEBV?$Matrix@M$0?0$0?0$0A@$0?0$0?0@Eigen@@AEAV?$Matrix@M$0?0$00$0A@$0?0$00@5@JJ@Z"]
    pub fn nam_convnet__Head_process_(
        this: *const nam_convnet__Head,
        input: *const Eigen_MatrixXf,
        output: *mut Eigen_VectorXf,
        i_start: ::std::os::raw::c_long,
        i_end: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}??0_Head@convnet@nam@@QEAA@HAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@Z"]
    pub fn nam_convnet__Head__Head(
        this: *mut nam_convnet__Head,
        channels: ::std::os::raw::c_int,
        weights: *mut u8,
    );
}
impl nam_convnet__Head {
    #[inline]
    pub unsafe fn process_(
        &self,
        input: *const Eigen_MatrixXf,
        output: *mut Eigen_VectorXf,
        i_start: ::std::os::raw::c_long,
        i_end: ::std::os::raw::c_long,
    ) {
        nam_convnet__Head_process_(self, input, output, i_start, i_end)
    }
    #[inline]
    pub unsafe fn new(channels: ::std::os::raw::c_int, weights: *mut u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_convnet__Head__Head(__bindgen_tmp.as_mut_ptr(), channels, weights);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_convnet_ConvNet {
    pub _base: nam_Buffer,
    _blocks: __BindgenOpaqueArray<u64, 3usize>,
    _block_vals: __BindgenOpaqueArray<u64, 3usize>,
    _head_output: Eigen_VectorXf,
    _head: nam_convnet__Head,
    mPrewarmSamples: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_convnet_ConvNet"][::std::mem::size_of::<nam_convnet_ConvNet>() - 232usize];
    ["Alignment of nam_convnet_ConvNet"][::std::mem::align_of::<nam_convnet_ConvNet>() - 8usize];
    ["Offset of field: nam_convnet_ConvNet::_blocks"]
        [::std::mem::offset_of!(nam_convnet_ConvNet, _blocks) - 136usize];
    ["Offset of field: nam_convnet_ConvNet::_block_vals"]
        [::std::mem::offset_of!(nam_convnet_ConvNet, _block_vals) - 160usize];
    ["Offset of field: nam_convnet_ConvNet::_head_output"]
        [::std::mem::offset_of!(nam_convnet_ConvNet, _head_output) - 184usize];
    ["Offset of field: nam_convnet_ConvNet::_head"]
        [::std::mem::offset_of!(nam_convnet_ConvNet, _head) - 200usize];
    ["Offset of field: nam_convnet_ConvNet::mPrewarmSamples"]
        [::std::mem::offset_of!(nam_convnet_ConvNet, mPrewarmSamples) - 224usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?_verify_weights@ConvNet@convnet@nam@@IEAAXHAEBV?$vector@HV?$allocator@H@std@@@std@@_N_K@Z"]
    pub fn nam_convnet_ConvNet__verify_weights(
        this: *mut nam_convnet_ConvNet,
        channels: ::std::os::raw::c_int,
        dilations: *const __BindgenOpaqueArray<u64, 3usize>,
        batchnorm: bool,
        actual_weights: usize,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}??0ConvNet@convnet@nam@@QEAA@HAEBV?$vector@HV?$allocator@H@std@@@std@@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@AEAV?$vector@MV?$allocator@M@std@@@4@N@Z"]
    pub fn nam_convnet_ConvNet_ConvNet(
        this: *mut nam_convnet_ConvNet,
        channels: ::std::os::raw::c_int,
        dilations: *const __BindgenOpaqueArray<u64, 3usize>,
        batchnorm: bool,
        activation: std_string,
        weights: *mut __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    );
}
impl nam_convnet_ConvNet {
    #[inline]
    pub unsafe fn _verify_weights(
        &mut self,
        channels: ::std::os::raw::c_int,
        dilations: *const __BindgenOpaqueArray<u64, 3usize>,
        batchnorm: bool,
        actual_weights: usize,
    ) {
        nam_convnet_ConvNet__verify_weights(self, channels, dilations, batchnorm, actual_weights)
    }
    #[inline]
    pub unsafe fn new(
        channels: ::std::os::raw::c_int,
        dilations: *const __BindgenOpaqueArray<u64, 3usize>,
        batchnorm: bool,
        activation: std_string,
        weights: *mut __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_convnet_ConvNet_ConvNet(
            __bindgen_tmp.as_mut_ptr(),
            channels,
            dilations,
            batchnorm,
            activation,
            weights,
            expected_sample_rate,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}?process@ConvNet@convnet@nam@@UEAAXPEAN0H@Z"]
    pub fn nam_convnet_ConvNet_process(
        this: *mut ::std::os::raw::c_void,
        input: *mut f64,
        output: *mut f64,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?_update_buffers_@ConvNet@convnet@nam@@MEAAXPEANH@Z"]
    pub fn nam_convnet_ConvNet__update_buffers_(
        this: *mut ::std::os::raw::c_void,
        input: *mut f64,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?_rewind_buffers_@ConvNet@convnet@nam@@MEAAXXZ"]
    pub fn nam_convnet_ConvNet__rewind_buffers_(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nam_lstm_LSTMCell {
    _w: Eigen_MatrixXf,
    _b: Eigen_VectorXf,
    _xh: Eigen_VectorXf,
    _ifgo: Eigen_VectorXf,
    _c: Eigen_VectorXf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_lstm_LSTMCell"][::std::mem::size_of::<nam_lstm_LSTMCell>() - 88usize];
    ["Alignment of nam_lstm_LSTMCell"][::std::mem::align_of::<nam_lstm_LSTMCell>() - 8usize];
    ["Offset of field: nam_lstm_LSTMCell::_w"]
        [::std::mem::offset_of!(nam_lstm_LSTMCell, _w) - 0usize];
    ["Offset of field: nam_lstm_LSTMCell::_b"]
        [::std::mem::offset_of!(nam_lstm_LSTMCell, _b) - 24usize];
    ["Offset of field: nam_lstm_LSTMCell::_xh"]
        [::std::mem::offset_of!(nam_lstm_LSTMCell, _xh) - 40usize];
    ["Offset of field: nam_lstm_LSTMCell::_ifgo"]
        [::std::mem::offset_of!(nam_lstm_LSTMCell, _ifgo) - 56usize];
    ["Offset of field: nam_lstm_LSTMCell::_c"]
        [::std::mem::offset_of!(nam_lstm_LSTMCell, _c) - 72usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?process_@LSTMCell@lstm@nam@@QEAAXAEBV?$Matrix@M$0?0$00$0A@$0?0$00@Eigen@@@Z"]
    pub fn nam_lstm_LSTMCell_process_(this: *mut nam_lstm_LSTMCell, x: *const Eigen_VectorXf);
}
unsafe extern "C" {
    #[link_name = "\u{1}??0LSTMCell@lstm@nam@@QEAA@HHAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@Z"]
    pub fn nam_lstm_LSTMCell_LSTMCell(
        this: *mut nam_lstm_LSTMCell,
        input_size: ::std::os::raw::c_int,
        hidden_size: ::std::os::raw::c_int,
        weights: *mut u8,
    );
}
impl nam_lstm_LSTMCell {
    #[inline]
    pub unsafe fn process_(&mut self, x: *const Eigen_VectorXf) {
        nam_lstm_LSTMCell_process_(self, x)
    }
    #[inline]
    pub unsafe fn new(
        input_size: ::std::os::raw::c_int,
        hidden_size: ::std::os::raw::c_int,
        weights: *mut u8,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_lstm_LSTMCell_LSTMCell(__bindgen_tmp.as_mut_ptr(), input_size, hidden_size, weights);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_lstm_LSTM {
    pub _base: nam_DSP,
    _head_weight: Eigen_VectorXf,
    _head_bias: f32,
    _layers: __BindgenOpaqueArray<u64, 3usize>,
    _input: Eigen_VectorXf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_lstm_LSTM"][::std::mem::size_of::<nam_lstm_LSTM>() - 136usize];
    ["Alignment of nam_lstm_LSTM"][::std::mem::align_of::<nam_lstm_LSTM>() - 8usize];
    ["Offset of field: nam_lstm_LSTM::_head_weight"]
        [::std::mem::offset_of!(nam_lstm_LSTM, _head_weight) - 72usize];
    ["Offset of field: nam_lstm_LSTM::_head_bias"]
        [::std::mem::offset_of!(nam_lstm_LSTM, _head_bias) - 88usize];
    ["Offset of field: nam_lstm_LSTM::_layers"]
        [::std::mem::offset_of!(nam_lstm_LSTM, _layers) - 96usize];
    ["Offset of field: nam_lstm_LSTM::_input"]
        [::std::mem::offset_of!(nam_lstm_LSTM, _input) - 120usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?_process_sample@LSTM@lstm@nam@@IEAAMM@Z"]
    pub fn nam_lstm_LSTM__process_sample(this: *mut nam_lstm_LSTM, x: f32) -> f32;
}
unsafe extern "C" {
    #[link_name = "\u{1}??0LSTM@lstm@nam@@QEAA@HHHAEAV?$vector@MV?$allocator@M@std@@@std@@N@Z"]
    pub fn nam_lstm_LSTM_LSTM(
        this: *mut nam_lstm_LSTM,
        num_layers: ::std::os::raw::c_int,
        input_size: ::std::os::raw::c_int,
        hidden_size: ::std::os::raw::c_int,
        weights: *mut __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    );
}
impl nam_lstm_LSTM {
    #[inline]
    pub unsafe fn _process_sample(&mut self, x: f32) -> f32 {
        nam_lstm_LSTM__process_sample(self, x)
    }
    #[inline]
    pub unsafe fn new(
        num_layers: ::std::os::raw::c_int,
        input_size: ::std::os::raw::c_int,
        hidden_size: ::std::os::raw::c_int,
        weights: *mut __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_lstm_LSTM_LSTM(
            __bindgen_tmp.as_mut_ptr(),
            num_layers,
            input_size,
            hidden_size,
            weights,
            expected_sample_rate,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}?PrewarmSamples@LSTM@lstm@nam@@MEAAHXZ"]
    pub fn nam_lstm_LSTM_PrewarmSamples(this: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}?process@LSTM@lstm@nam@@MEAAXPEAN0H@Z"]
    pub fn nam_lstm_LSTM_process(
        this: *mut ::std::os::raw::c_void,
        input: *mut f64,
        output: *mut f64,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?lowercase@util@nam@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z"]
    pub fn nam_util_lowercase(s: *const std_string) -> std_string;
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_wavenet__DilatedConv {
    pub _base: nam_Conv1D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_wavenet__DilatedConv"]
        [::std::mem::size_of::<nam_wavenet__DilatedConv>() - 48usize];
    ["Alignment of nam_wavenet__DilatedConv"]
        [::std::mem::align_of::<nam_wavenet__DilatedConv>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}??0_DilatedConv@wavenet@nam@@QEAA@HHHHH@Z"]
    pub fn nam_wavenet__DilatedConv__DilatedConv(
        this: *mut nam_wavenet__DilatedConv,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        bias: ::std::os::raw::c_int,
        dilation: ::std::os::raw::c_int,
    );
}
impl nam_wavenet__DilatedConv {
    #[inline]
    pub unsafe fn new(
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        bias: ::std::os::raw::c_int,
        dilation: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_wavenet__DilatedConv__DilatedConv(
            __bindgen_tmp.as_mut_ptr(),
            in_channels,
            out_channels,
            kernel_size,
            bias,
            dilation,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_wavenet__Layer {
    _conv: nam_wavenet__DilatedConv,
    _input_mixin: nam_Conv1x1,
    _1x1: nam_Conv1x1,
    _z: Eigen_MatrixXf,
    _activation: *mut nam_activations_Activation,
    _gated: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_wavenet__Layer"][::std::mem::size_of::<nam_wavenet__Layer>() - 232usize];
    ["Alignment of nam_wavenet__Layer"][::std::mem::align_of::<nam_wavenet__Layer>() - 8usize];
    ["Offset of field: nam_wavenet__Layer::_conv"]
        [::std::mem::offset_of!(nam_wavenet__Layer, _conv) - 0usize];
    ["Offset of field: nam_wavenet__Layer::_input_mixin"]
        [::std::mem::offset_of!(nam_wavenet__Layer, _input_mixin) - 48usize];
    ["Offset of field: nam_wavenet__Layer::_1x1"]
        [::std::mem::offset_of!(nam_wavenet__Layer, _1x1) - 120usize];
    ["Offset of field: nam_wavenet__Layer::_z"]
        [::std::mem::offset_of!(nam_wavenet__Layer, _z) - 192usize];
    ["Offset of field: nam_wavenet__Layer::_activation"]
        [::std::mem::offset_of!(nam_wavenet__Layer, _activation) - 216usize];
    ["Offset of field: nam_wavenet__Layer::_gated"]
        [::std::mem::offset_of!(nam_wavenet__Layer, _gated) - 224usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?SetMaxBufferSize@_Layer@wavenet@nam@@QEAAXH@Z"]
    pub fn nam_wavenet__Layer_SetMaxBufferSize(
        this: *mut nam_wavenet__Layer,
        maxBufferSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?set_weights_@_Layer@wavenet@nam@@QEAAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@Z"]
    pub fn nam_wavenet__Layer_set_weights_(this: *mut nam_wavenet__Layer, weights: *mut u8);
}
unsafe extern "C" {
    #[link_name = "\u{1}?process_@_Layer@wavenet@nam@@QEAAXAEBV?$Matrix@M$0?0$0?0$0A@$0?0$0?0@Eigen@@0AEAV45@1JJH@Z"]
    pub fn nam_wavenet__Layer_process_(
        this: *mut nam_wavenet__Layer,
        input: *const Eigen_MatrixXf,
        condition: *const Eigen_MatrixXf,
        head_input: *mut Eigen_MatrixXf,
        output: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        j_start: ::std::os::raw::c_long,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?set_num_frames_@_Layer@wavenet@nam@@QEAAXJ@Z"]
    pub fn nam_wavenet__Layer_set_num_frames_(
        this: *mut nam_wavenet__Layer,
        num_frames: ::std::os::raw::c_long,
    );
}
impl nam_wavenet__Layer {
    #[inline]
    pub unsafe fn SetMaxBufferSize(&mut self, maxBufferSize: ::std::os::raw::c_int) {
        nam_wavenet__Layer_SetMaxBufferSize(self, maxBufferSize)
    }
    #[inline]
    pub unsafe fn set_weights_(&mut self, weights: *mut u8) {
        nam_wavenet__Layer_set_weights_(self, weights)
    }
    #[inline]
    pub unsafe fn process_(
        &mut self,
        input: *const Eigen_MatrixXf,
        condition: *const Eigen_MatrixXf,
        head_input: *mut Eigen_MatrixXf,
        output: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        j_start: ::std::os::raw::c_long,
        num_frames: ::std::os::raw::c_int,
    ) {
        nam_wavenet__Layer_process_(
            self, input, condition, head_input, output, i_start, j_start, num_frames,
        )
    }
    #[inline]
    pub unsafe fn set_num_frames_(&mut self, num_frames: ::std::os::raw::c_long) {
        nam_wavenet__Layer_set_num_frames_(self, num_frames)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_wavenet_LayerArrayParams {
    pub input_size: ::std::os::raw::c_int,
    pub condition_size: ::std::os::raw::c_int,
    pub head_size: ::std::os::raw::c_int,
    pub channels: ::std::os::raw::c_int,
    pub kernel_size: ::std::os::raw::c_int,
    pub dilations: __BindgenOpaqueArray<u64, 3usize>,
    pub activation: std_string,
    pub gated: bool,
    pub head_bias: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_wavenet_LayerArrayParams"]
        [::std::mem::size_of::<nam_wavenet_LayerArrayParams>() - 88usize];
    ["Alignment of nam_wavenet_LayerArrayParams"]
        [::std::mem::align_of::<nam_wavenet_LayerArrayParams>() - 8usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::input_size"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, input_size) - 0usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::condition_size"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, condition_size) - 4usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::head_size"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, head_size) - 8usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::channels"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, channels) - 12usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::kernel_size"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, kernel_size) - 16usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::dilations"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, dilations) - 24usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::activation"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, activation) - 48usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::gated"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, gated) - 80usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::head_bias"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, head_bias) - 81usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct nam_wavenet__LayerArray {
    _buffer_start: ::std::os::raw::c_long,
    _rechannel: nam_Conv1x1,
    _layer_buffers: __BindgenOpaqueArray<u64, 3usize>,
    _layers: __BindgenOpaqueArray<u64, 3usize>,
    _head_rechannel: nam_Conv1x1,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_wavenet__LayerArray"]
        [::std::mem::size_of::<nam_wavenet__LayerArray>() - 200usize];
    ["Alignment of nam_wavenet__LayerArray"]
        [::std::mem::align_of::<nam_wavenet__LayerArray>() - 8usize];
    ["Offset of field: nam_wavenet__LayerArray::_buffer_start"]
        [::std::mem::offset_of!(nam_wavenet__LayerArray, _buffer_start) - 0usize];
    ["Offset of field: nam_wavenet__LayerArray::_rechannel"]
        [::std::mem::offset_of!(nam_wavenet__LayerArray, _rechannel) - 8usize];
    ["Offset of field: nam_wavenet__LayerArray::_layer_buffers"]
        [::std::mem::offset_of!(nam_wavenet__LayerArray, _layer_buffers) - 80usize];
    ["Offset of field: nam_wavenet__LayerArray::_layers"]
        [::std::mem::offset_of!(nam_wavenet__LayerArray, _layers) - 104usize];
    ["Offset of field: nam_wavenet__LayerArray::_head_rechannel"]
        [::std::mem::offset_of!(nam_wavenet__LayerArray, _head_rechannel) - 128usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?SetMaxBufferSize@_LayerArray@wavenet@nam@@QEAAXH@Z"]
    pub fn nam_wavenet__LayerArray_SetMaxBufferSize(
        this: *mut nam_wavenet__LayerArray,
        maxBufferSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?advance_buffers_@_LayerArray@wavenet@nam@@QEAAXH@Z"]
    pub fn nam_wavenet__LayerArray_advance_buffers_(
        this: *mut nam_wavenet__LayerArray,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?prepare_for_frames_@_LayerArray@wavenet@nam@@QEAAXJ@Z"]
    pub fn nam_wavenet__LayerArray_prepare_for_frames_(
        this: *mut nam_wavenet__LayerArray,
        num_frames: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?process_@_LayerArray@wavenet@nam@@QEAAXAEBV?$Matrix@M$0?0$0?0$0A@$0?0$0?0@Eigen@@0AEAV45@11H@Z"]
    pub fn nam_wavenet__LayerArray_process_(
        this: *mut nam_wavenet__LayerArray,
        layer_inputs: *const Eigen_MatrixXf,
        condition: *const Eigen_MatrixXf,
        layer_outputs: *mut Eigen_MatrixXf,
        head_inputs: *mut Eigen_MatrixXf,
        head_outputs: *mut Eigen_MatrixXf,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?set_num_frames_@_LayerArray@wavenet@nam@@QEAAXJ@Z"]
    pub fn nam_wavenet__LayerArray_set_num_frames_(
        this: *mut nam_wavenet__LayerArray,
        num_frames: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?set_weights_@_LayerArray@wavenet@nam@@QEAAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@Z"]
    pub fn nam_wavenet__LayerArray_set_weights_(this: *mut nam_wavenet__LayerArray, it: *mut u8);
}
unsafe extern "C" {
    #[link_name = "\u{1}?get_receptive_field@_LayerArray@wavenet@nam@@QEBAJXZ"]
    pub fn nam_wavenet__LayerArray_get_receptive_field(
        this: *const nam_wavenet__LayerArray,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    #[link_name = "\u{1}??0_LayerArray@wavenet@nam@@QEAA@HHHHHAEBV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@_N2@Z"]
    pub fn nam_wavenet__LayerArray__LayerArray(
        this: *mut nam_wavenet__LayerArray,
        input_size: ::std::os::raw::c_int,
        condition_size: ::std::os::raw::c_int,
        head_size: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        dilations: *const __BindgenOpaqueArray<u64, 3usize>,
        activation: std_string,
        gated: bool,
        head_bias: bool,
    );
}
impl nam_wavenet__LayerArray {
    #[inline]
    pub unsafe fn SetMaxBufferSize(&mut self, maxBufferSize: ::std::os::raw::c_int) {
        nam_wavenet__LayerArray_SetMaxBufferSize(self, maxBufferSize)
    }
    #[inline]
    pub unsafe fn advance_buffers_(&mut self, num_frames: ::std::os::raw::c_int) {
        nam_wavenet__LayerArray_advance_buffers_(self, num_frames)
    }
    #[inline]
    pub unsafe fn prepare_for_frames_(&mut self, num_frames: ::std::os::raw::c_long) {
        nam_wavenet__LayerArray_prepare_for_frames_(self, num_frames)
    }
    #[inline]
    pub unsafe fn process_(
        &mut self,
        layer_inputs: *const Eigen_MatrixXf,
        condition: *const Eigen_MatrixXf,
        layer_outputs: *mut Eigen_MatrixXf,
        head_inputs: *mut Eigen_MatrixXf,
        head_outputs: *mut Eigen_MatrixXf,
        num_frames: ::std::os::raw::c_int,
    ) {
        nam_wavenet__LayerArray_process_(
            self,
            layer_inputs,
            condition,
            layer_outputs,
            head_inputs,
            head_outputs,
            num_frames,
        )
    }
    #[inline]
    pub unsafe fn set_num_frames_(&mut self, num_frames: ::std::os::raw::c_long) {
        nam_wavenet__LayerArray_set_num_frames_(self, num_frames)
    }
    #[inline]
    pub unsafe fn set_weights_(&mut self, it: *mut u8) {
        nam_wavenet__LayerArray_set_weights_(self, it)
    }
    #[inline]
    pub unsafe fn get_receptive_field(&self) -> ::std::os::raw::c_long {
        nam_wavenet__LayerArray_get_receptive_field(self)
    }
    #[inline]
    pub unsafe fn new(
        input_size: ::std::os::raw::c_int,
        condition_size: ::std::os::raw::c_int,
        head_size: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        dilations: *const __BindgenOpaqueArray<u64, 3usize>,
        activation: std_string,
        gated: bool,
        head_bias: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_wavenet__LayerArray__LayerArray(
            __bindgen_tmp.as_mut_ptr(),
            input_size,
            condition_size,
            head_size,
            channels,
            kernel_size,
            dilations,
            activation,
            gated,
            head_bias,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_wavenet__Head {
    _channels: ::std::os::raw::c_int,
    _layers: __BindgenOpaqueArray<u64, 3usize>,
    _head: nam_Conv1x1,
    _activation: *mut nam_activations_Activation,
    _buffers: __BindgenOpaqueArray<u64, 3usize>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_wavenet__Head"][::std::mem::size_of::<nam_wavenet__Head>() - 136usize];
    ["Alignment of nam_wavenet__Head"][::std::mem::align_of::<nam_wavenet__Head>() - 8usize];
    ["Offset of field: nam_wavenet__Head::_channels"]
        [::std::mem::offset_of!(nam_wavenet__Head, _channels) - 0usize];
    ["Offset of field: nam_wavenet__Head::_layers"]
        [::std::mem::offset_of!(nam_wavenet__Head, _layers) - 8usize];
    ["Offset of field: nam_wavenet__Head::_head"]
        [::std::mem::offset_of!(nam_wavenet__Head, _head) - 32usize];
    ["Offset of field: nam_wavenet__Head::_activation"]
        [::std::mem::offset_of!(nam_wavenet__Head, _activation) - 104usize];
    ["Offset of field: nam_wavenet__Head::_buffers"]
        [::std::mem::offset_of!(nam_wavenet__Head, _buffers) - 112usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?Reset@_Head@wavenet@nam@@QEAAXNH@Z"]
    pub fn nam_wavenet__Head_Reset(
        this: *mut nam_wavenet__Head,
        sampleRate: f64,
        maxBufferSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?set_weights_@_Head@wavenet@nam@@QEAAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@Z"]
    pub fn nam_wavenet__Head_set_weights_(this: *mut nam_wavenet__Head, weights: *mut u8);
}
unsafe extern "C" {
    #[link_name = "\u{1}?process_@_Head@wavenet@nam@@QEAAXAEAV?$Matrix@M$0?0$0?0$0A@$0?0$0?0@Eigen@@0@Z"]
    pub fn nam_wavenet__Head_process_(
        this: *mut nam_wavenet__Head,
        inputs: *mut Eigen_MatrixXf,
        outputs: *mut Eigen_MatrixXf,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?set_num_frames_@_Head@wavenet@nam@@QEAAXJ@Z"]
    pub fn nam_wavenet__Head_set_num_frames_(
        this: *mut nam_wavenet__Head,
        num_frames: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}??0_Head@wavenet@nam@@QEAA@HHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn nam_wavenet__Head__Head(
        this: *mut nam_wavenet__Head,
        input_size: ::std::os::raw::c_int,
        num_layers: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        activation: std_string,
    );
}
impl nam_wavenet__Head {
    #[inline]
    pub unsafe fn Reset(&mut self, sampleRate: f64, maxBufferSize: ::std::os::raw::c_int) {
        nam_wavenet__Head_Reset(self, sampleRate, maxBufferSize)
    }
    #[inline]
    pub unsafe fn set_weights_(&mut self, weights: *mut u8) {
        nam_wavenet__Head_set_weights_(self, weights)
    }
    #[inline]
    pub unsafe fn process_(&mut self, inputs: *mut Eigen_MatrixXf, outputs: *mut Eigen_MatrixXf) {
        nam_wavenet__Head_process_(self, inputs, outputs)
    }
    #[inline]
    pub unsafe fn set_num_frames_(&mut self, num_frames: ::std::os::raw::c_long) {
        nam_wavenet__Head_set_num_frames_(self, num_frames)
    }
    #[inline]
    pub unsafe fn new(
        input_size: ::std::os::raw::c_int,
        num_layers: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        activation: std_string,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_wavenet__Head__Head(
            __bindgen_tmp.as_mut_ptr(),
            input_size,
            num_layers,
            channels,
            activation,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_wavenet_WaveNet {
    pub _base: nam_DSP,
    _condition: Eigen_MatrixXf,
    _layer_arrays: __BindgenOpaqueArray<u64, 3usize>,
    _layer_array_outputs: __BindgenOpaqueArray<u64, 3usize>,
    _head_arrays: __BindgenOpaqueArray<u64, 3usize>,
    _head_scale: f32,
    _head_output: Eigen_MatrixXf,
    mPrewarmSamples: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_wavenet_WaveNet"][::std::mem::size_of::<nam_wavenet_WaveNet>() - 208usize];
    ["Alignment of nam_wavenet_WaveNet"][::std::mem::align_of::<nam_wavenet_WaveNet>() - 8usize];
    ["Offset of field: nam_wavenet_WaveNet::_condition"]
        [::std::mem::offset_of!(nam_wavenet_WaveNet, _condition) - 72usize];
    ["Offset of field: nam_wavenet_WaveNet::_layer_arrays"]
        [::std::mem::offset_of!(nam_wavenet_WaveNet, _layer_arrays) - 96usize];
    ["Offset of field: nam_wavenet_WaveNet::_layer_array_outputs"]
        [::std::mem::offset_of!(nam_wavenet_WaveNet, _layer_array_outputs) - 120usize];
    ["Offset of field: nam_wavenet_WaveNet::_head_arrays"]
        [::std::mem::offset_of!(nam_wavenet_WaveNet, _head_arrays) - 144usize];
    ["Offset of field: nam_wavenet_WaveNet::_head_scale"]
        [::std::mem::offset_of!(nam_wavenet_WaveNet, _head_scale) - 168usize];
    ["Offset of field: nam_wavenet_WaveNet::_head_output"]
        [::std::mem::offset_of!(nam_wavenet_WaveNet, _head_output) - 176usize];
    ["Offset of field: nam_wavenet_WaveNet::mPrewarmSamples"]
        [::std::mem::offset_of!(nam_wavenet_WaveNet, mPrewarmSamples) - 200usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}?set_weights_@WaveNet@wavenet@nam@@QEAAXAEAV?$vector@MV?$allocator@M@std@@@std@@@Z"]
    pub fn nam_wavenet_WaveNet_set_weights_(
        this: *mut nam_wavenet_WaveNet,
        weights: *mut __BindgenOpaqueArray<u64, 3usize>,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}??0WaveNet@wavenet@nam@@QEAA@AEBV?$vector@VLayerArrayParams@wavenet@nam@@V?$allocator@VLayerArrayParams@wavenet@nam@@@std@@@std@@M_NV?$vector@MV?$allocator@M@std@@@4@N@Z"]
    pub fn nam_wavenet_WaveNet_WaveNet(
        this: *mut nam_wavenet_WaveNet,
        layer_array_params: *const u8,
        head_scale: f32,
        with_head: bool,
        weights: __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    );
}
impl nam_wavenet_WaveNet {
    #[inline]
    pub unsafe fn set_weights_(&mut self, weights: *mut __BindgenOpaqueArray<u64, 3usize>) {
        nam_wavenet_WaveNet_set_weights_(self, weights)
    }
    #[inline]
    pub unsafe fn new(
        layer_array_params: *const u8,
        head_scale: f32,
        with_head: bool,
        weights: __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_wavenet_WaveNet_WaveNet(
            __bindgen_tmp.as_mut_ptr(),
            layer_array_params,
            head_scale,
            with_head,
            weights,
            expected_sample_rate,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}?process@WaveNet@wavenet@nam@@UEAAXPEAN0H@Z"]
    pub fn nam_wavenet_WaveNet_process(
        this: *mut ::std::os::raw::c_void,
        input: *mut f64,
        output: *mut f64,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?SetMaxBufferSize@WaveNet@wavenet@nam@@MEAAXH@Z"]
    pub fn nam_wavenet_WaveNet_SetMaxBufferSize(
        this: *mut ::std::os::raw::c_void,
        maxBufferSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?_set_condition_array@WaveNet@wavenet@nam@@MEAAXPEANH@Z"]
    pub fn nam_wavenet_WaveNet__set_condition_array(
        this: *mut ::std::os::raw::c_void,
        input: *mut f64,
        num_frames: ::std::os::raw::c_int,
    );
}
#[doc = "@brief default JSON class\n\nThis type is the default specialization of the @ref basic_json class which\nuses the standard template types.\n\n@since version 1.0.0"]
pub type nlohmann_json = __BindgenOpaqueArray<u64, 2usize>;
unsafe extern "C" {
    #[link_name = "\u{1}?get_dsp_from_string_path@@YAPEAVDSP@nam@@PEBD@Z"]
    pub fn get_dsp_from_string_path(str_: *const ::std::os::raw::c_char) -> *mut nam_DSP;
}
unsafe extern "C" {
    #[link_name = "\u{1}?get_dsp_expected_sample_rate@@YANPEAVDSP@nam@@@Z"]
    pub fn get_dsp_expected_sample_rate(dsp: *mut nam_DSP) -> f64;
}
unsafe extern "C" {
    #[link_name = "\u{1}?dsp_process@@YAXPEAVDSP@nam@@PEAM1H@Z"]
    pub fn dsp_process(
        dsp: *mut nam_DSP,
        input: *mut f32,
        output: *mut f32,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}?destroy_dsp@@YAXPEAVDSP@nam@@@Z"]
    pub fn destroy_dsp(dsp: *mut nam_DSP);
}
