/* automatically generated by rust-bindgen 0.71.1 */

#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
pub const __glibcxx_incomplete_container_elements: u32 = 201505;
pub const __glibcxx_uncaught_exceptions: u32 = 201411;
pub const __glibcxx_allocator_traits_is_always_equal: u32 = 201411;
pub const __glibcxx_is_null_pointer: u32 = 201309;
pub const __glibcxx_result_of_sfinae: u32 = 201210;
pub const __glibcxx_shared_ptr_arrays: u32 = 201611;
pub const __glibcxx_is_swappable: u32 = 201603;
pub const __glibcxx_void_t: u32 = 201411;
pub const __glibcxx_enable_shared_from_this: u32 = 201603;
pub const __glibcxx_math_spec_funcs: u32 = 201003;
pub const __glibcxx_exchange_function: u32 = 201304;
pub const __glibcxx_integer_sequence: u32 = 201304;
pub const __glibcxx_integral_constant_callable: u32 = 201304;
pub const __glibcxx_is_final: u32 = 201402;
pub const __glibcxx_make_reverse_iterator: u32 = 201402;
pub const __glibcxx_null_iterators: u32 = 201304;
pub const __glibcxx_transformation_trait_aliases: u32 = 201304;
pub const __glibcxx_transparent_operators: u32 = 201510;
pub const __glibcxx_tuple_element_t: u32 = 201402;
pub const __glibcxx_tuples_by_type: u32 = 201304;
pub const __glibcxx_robust_nonmodifying_seq_ops: u32 = 201304;
pub const __glibcxx_to_chars: u32 = 201611;
pub const __glibcxx_chrono_udls: u32 = 201304;
pub const __glibcxx_complex_udls: u32 = 201309;
pub const __glibcxx_generic_associative_lookup: u32 = 201304;
pub const __glibcxx_make_unique: u32 = 201304;
pub const __glibcxx_quoted_string_io: u32 = 201304;
pub const __glibcxx_shared_timed_mutex: u32 = 201402;
pub const __glibcxx_string_udls: u32 = 201304;
pub const __glibcxx_addressof_constexpr: u32 = 201603;
pub const __glibcxx_any: u32 = 201606;
pub const __glibcxx_apply: u32 = 201603;
pub const __glibcxx_as_const: u32 = 201510;
pub const __glibcxx_atomic_is_always_lock_free: u32 = 201603;
pub const __glibcxx_bool_constant: u32 = 201505;
pub const __glibcxx_byte: u32 = 201603;
pub const __glibcxx_has_unique_object_representations: u32 = 201606;
pub const __glibcxx_hardware_interference_size: u32 = 201703;
pub const __glibcxx_invoke: u32 = 201411;
pub const __glibcxx_is_aggregate: u32 = 201703;
pub const __glibcxx_is_invocable: u32 = 201703;
pub const __glibcxx_launder: u32 = 201606;
pub const __glibcxx_logical_traits: u32 = 201510;
pub const __glibcxx_make_from_tuple: u32 = 201606;
pub const __glibcxx_not_fn: u32 = 201603;
pub const __glibcxx_type_trait_variable_templates: u32 = 201510;
pub const __glibcxx_variant: u32 = 202102;
pub const __glibcxx_lcm: u32 = 201606;
pub const __glibcxx_gcd: u32 = 201606;
pub const __glibcxx_gcd_lcm: u32 = 201606;
pub const __glibcxx_raw_memory_algorithms: u32 = 201606;
pub const __glibcxx_array_constexpr: u32 = 201803;
pub const __glibcxx_nonmember_container_access: u32 = 201411;
pub const __glibcxx_clamp: u32 = 201603;
pub const __glibcxx_sample: u32 = 201603;
pub const __glibcxx_boyer_moore_searcher: u32 = 201603;
pub const __glibcxx_chrono: u32 = 201611;
pub const __glibcxx_execution: u32 = 201902;
pub const __glibcxx_filesystem: u32 = 201703;
pub const __cpp_lib_filesystem: u32 = 201703;
pub const __glibcxx_hypot: u32 = 201603;
pub const __glibcxx_map_try_emplace: u32 = 201411;
pub const __glibcxx_math_special_functions: u32 = 201603;
pub const __glibcxx_memory_resource: u32 = 201603;
pub const __glibcxx_node_extract: u32 = 201606;
pub const __glibcxx_parallel_algorithm: u32 = 201603;
pub const __glibcxx_scoped_lock: u32 = 201703;
pub const __glibcxx_shared_mutex: u32 = 201505;
pub const __glibcxx_shared_ptr_weak_type: u32 = 201606;
pub const __glibcxx_string_view: u32 = 201803;
pub const __glibcxx_unordered_map_try_emplace: u32 = 201411;
pub const __glibcxx_optional: u32 = 201606;
pub const __glibcxx_constexpr_char_traits: u32 = 201611;
pub const __glibcxx_constexpr_string: u32 = 201611;
pub const __cpp_lib_uncaught_exceptions: u32 = 201411;
pub const __cpp_lib_hardware_interference_size: u32 = 201703;
pub const __cpp_lib_launder: u32 = 201606;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const __cpp_lib_is_swappable: u32 = 201603;
pub const __cpp_lib_void_t: u32 = 201411;
pub const __cpp_lib_integral_constant_callable: u32 = 201304;
pub const __cpp_lib_is_final: u32 = 201402;
pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
pub const __cpp_lib_bool_constant: u32 = 201505;
pub const __cpp_lib_has_unique_object_representations: u32 = 201606;
pub const __cpp_lib_is_aggregate: u32 = 201703;
pub const __cpp_lib_is_invocable: u32 = 201703;
pub const __cpp_lib_logical_traits: u32 = 201510;
pub const __cpp_lib_type_trait_variable_templates: u32 = 201510;
pub const __cpp_lib_string_view: u32 = 201803;
pub const __cpp_lib_constexpr_char_traits: u32 = 201611;
pub const __cpp_lib_string_udls: u32 = 201304;
pub const __cpp_lib_nonmember_container_access: u32 = 201411;
pub const __cpp_lib_constexpr_string: u32 = 201611;
pub const __cpp_lib_byte: u32 = 201603;
pub const __cpp_lib_tuple_element_t: u32 = 201402;
pub const __cpp_lib_tuples_by_type: u32 = 201304;
pub const __cpp_lib_apply: u32 = 201603;
pub const __cpp_lib_make_from_tuple: u32 = 201606;
pub const __cpp_lib_quoted_string_io: u32 = 201304;
pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
pub const __cpp_lib_null_iterators: u32 = 201304;
pub const __cpp_lib_array_constexpr: u32 = 201803;
pub const __cpp_lib_allocator_traits_is_always_equal: u32 = 201411;
pub const __cpp_lib_shared_ptr_arrays: u32 = 201611;
pub const __cpp_lib_enable_shared_from_this: u32 = 201603;
pub const __cpp_lib_transparent_operators: u32 = 201510;
pub const __cpp_lib_make_unique: u32 = 201304;
pub const __cpp_lib_raw_memory_algorithms: u32 = 201606;
pub const __cpp_lib_parallel_algorithm: u32 = 201603;
pub const __cpp_lib_shared_ptr_weak_type: u32 = 201606;
pub const __cpp_lib_node_extract: u32 = 201606;
pub const __cpp_lib_unordered_map_try_emplace: u32 = 201411;
pub const __cpp_lib_incomplete_container_elements: u32 = 201505;
pub const __cpp_lib_hypot: u32 = 201603;
pub const __STDCPP_MATH_SPEC_FUNCS__: u32 = 201003;
pub const __cpp_lib_math_special_functions: u32 = 201603;
pub const _GLIBCXX_TR1_SPECIAL_FUNCTION_UTIL_H: u32 = 1;
pub const __cpp_lib_complex_udls: u32 = 201309;
pub const __cpp_lib_invoke: u32 = 201411;
pub const __cpp_lib_not_fn: u32 = 201603;
pub const __cpp_lib_boyer_moore_searcher: u32 = 201603;
pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
pub const __cpp_lib_clamp: u32 = 201603;
pub const __cpp_lib_sample: u32 = 201603;
pub const __cpp_lib_lcm: u32 = 201606;
pub const __cpp_lib_gcd: u32 = 201606;
pub const __cpp_lib_gcd_lcm: u32 = 201606;
pub const __cpp_lib_exchange_function: u32 = 201304;
pub const __cpp_lib_integer_sequence: u32 = 201304;
pub const __cpp_lib_addressof_constexpr: u32 = 201603;
pub const __cpp_lib_as_const: u32 = 201510;
pub const __cpp_lib_generic_associative_lookup: u32 = 201304;
pub const __cpp_lib_map_try_emplace: u32 = 201411;
pub const NAM_UNKNOWN_EXPECTED_SAMPLE_RATE: f64 = -1.0;
pub const NEURAL_AMP_MODELER_DSP_VERSION_MAJOR: u32 = 0;
pub const NEURAL_AMP_MODELER_DSP_VERSION_MINOR: u32 = 3;
pub const NEURAL_AMP_MODELER_DSP_VERSION_PATCH: u32 = 0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string {
    pub _address: u8,
}
pub type std_basic_string__Char_alloc_type = u8;
pub type std_basic_string__Alloc_traits = u8;
pub type std_basic_string_traits_type = u8;
pub type std_basic_string_value_type = u8;
pub type std_basic_string_allocator_type = u8;
pub type std_basic_string_size_type = u8;
pub type std_basic_string_difference_type = u8;
pub type std_basic_string_reference = u8;
pub type std_basic_string_const_reference = u8;
pub type std_basic_string_pointer = u8;
pub type std_basic_string_const_pointer = u8;
pub type std_basic_string_iterator = u8;
pub type std_basic_string_const_iterator = u8;
pub type std_basic_string_const_reverse_iterator = u8;
pub type std_basic_string_reverse_iterator = u8;
pub type std_basic_string___const_iterator = u8;
pub type std_basic_string___sv_type = u8;
pub type std_basic_string__If_sv = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___sv_wrapper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string__Alloc_hider {
    pub _address: u8,
}
pub const std_basic_string__S_local_capacity: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union std_basic_string__bindgen_ty_2 {
    pub _bindgen_opaque_blob: u64,
}
pub type std_string = __BindgenOpaqueArray<u64, 4usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___floating_point_constant {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___numeric_constants {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_value_type = u8;
pub type std_allocator_size_type = u64;
pub type std_allocator_difference_type = u64;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair {
    pub _address: u8,
}
pub type std_pair_first_type = u8;
pub type std_pair_second_type = u8;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair___zero_as_null_pointer_constant {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string_view {
    pub _address: u8,
}
pub type std_basic_string_view_traits_type = u8;
pub type std_basic_string_view_value_type = u8;
pub type std_basic_string_view_pointer = u8;
pub type std_basic_string_view_const_pointer = u8;
pub type std_basic_string_view_reference = u8;
pub type std_basic_string_view_const_reference = u8;
pub type std_basic_string_view_const_iterator = u8;
pub type std_basic_string_view_iterator = u8;
pub type std_basic_string_view_const_reverse_iterator = u8;
pub type std_basic_string_view_reverse_iterator = u8;
pub type std_basic_string_view_size_type = u64;
pub type std_basic_string_view_difference_type = u64;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_filesystem_path {
    pub _bindgen_opaque_blob: [u64; 5usize],
}
pub type std_filesystem_path_value_type = u16;
pub type std_filesystem_path_string_type = __BindgenOpaqueArray<u64, 4usize>;
pub const std_filesystem_path_format_native_format: std_filesystem_path_format = 0;
pub const std_filesystem_path_format_generic_format: std_filesystem_path_format = 1;
pub const std_filesystem_path_format_auto_format: std_filesystem_path_format = 2;
pub type std_filesystem_path_format = ::std::os::raw::c_uchar;
pub type std_filesystem_path_const_iterator = __BindgenOpaqueArray<u64, 3usize>;
pub const std_filesystem_path__Type__Multi: std_filesystem_path__Type = 0;
pub const std_filesystem_path__Type__Root_name: std_filesystem_path__Type = 1;
pub const std_filesystem_path__Type__Root_dir: std_filesystem_path__Type = 2;
pub const std_filesystem_path__Type__Filename: std_filesystem_path__Type = 3;
pub type std_filesystem_path__Type = ::std::os::raw::c_uchar;
pub const std_filesystem_path__Split__Stem: std_filesystem_path__Split = 0;
pub const std_filesystem_path__Split__Extension: std_filesystem_path__Split = 1;
pub type std_filesystem_path__Split = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_filesystem_path__List {
    pub _bindgen_opaque_blob: u64,
}
pub type std_filesystem_path__List_value_type = __BindgenOpaqueArray<u64, 6usize>;
pub type std_filesystem_path__List_iterator = u64;
pub type std_filesystem_path__List_const_iterator = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_filesystem_path__List__Impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_filesystem_path__List__Impl_deleter {
    pub _bindgen_opaque_blob: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_filesystem_path__List__Impl_deleter"]
        [::std::mem::size_of::<std_filesystem_path__List__Impl_deleter>() - 1usize];
    ["Alignment of std_filesystem_path__List__Impl_deleter"]
        [::std::mem::align_of::<std_filesystem_path__List__Impl_deleter>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_filesystem_path__List"]
        [::std::mem::size_of::<std_filesystem_path__List>() - 8usize];
    ["Alignment of std_filesystem_path__List"]
        [::std::mem::align_of::<std_filesystem_path__List>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path5_List4typeENS1_5_TypeE"]
    pub fn std_filesystem_path__List_type(
        this: *mut std_filesystem_path__List,
        arg1: std_filesystem_path__Type,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path5_List4sizeEv"]
    pub fn std_filesystem_path__List_size(
        this: *const std_filesystem_path__List,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path5_List5emptyEv"]
    pub fn std_filesystem_path__List_empty(this: *const std_filesystem_path__List) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path5_List5clearEv"]
    pub fn std_filesystem_path__List_clear(this: *mut std_filesystem_path__List);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path5_List8capacityEv"]
    pub fn std_filesystem_path__List_capacity(
        this: *const std_filesystem_path__List,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path5_List7reserveEib"]
    pub fn std_filesystem_path__List_reserve(
        this: *mut std_filesystem_path__List,
        arg1: ::std::os::raw::c_int,
        arg2: bool,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path5_List5beginEv"]
    pub fn std_filesystem_path__List_begin(
        this: *mut std_filesystem_path__List,
    ) -> std_filesystem_path__List_iterator;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path5_List3endEv"]
    pub fn std_filesystem_path__List_end(
        this: *mut std_filesystem_path__List,
    ) -> std_filesystem_path__List_iterator;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path5_List5beginEv"]
    pub fn std_filesystem_path__List_begin1(
        this: *const std_filesystem_path__List,
    ) -> std_filesystem_path__List_const_iterator;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path5_List3endEv"]
    pub fn std_filesystem_path__List_end1(
        this: *const std_filesystem_path__List,
    ) -> std_filesystem_path__List_const_iterator;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path5_List5frontEv"]
    pub fn std_filesystem_path__List_front(
        this: *mut std_filesystem_path__List,
    ) -> *mut std_filesystem_path__List_value_type;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path5_List4backEv"]
    pub fn std_filesystem_path__List_back(
        this: *mut std_filesystem_path__List,
    ) -> *mut std_filesystem_path__List_value_type;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path5_List5frontEv"]
    pub fn std_filesystem_path__List_front1(
        this: *const std_filesystem_path__List,
    ) -> *const std_filesystem_path__List_value_type;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path5_List4backEv"]
    pub fn std_filesystem_path__List_back1(
        this: *const std_filesystem_path__List,
    ) -> *const std_filesystem_path__List_value_type;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path5_List8pop_backEv"]
    pub fn std_filesystem_path__List_pop_back(this: *mut std_filesystem_path__List);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path5_List13_M_erase_fromEPKNS1_5_CmptE"]
    pub fn std_filesystem_path__List__M_erase_from(
        this: *mut std_filesystem_path__List,
        __pos: std_filesystem_path__List_const_iterator,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path5_ListC1Ev"]
    pub fn std_filesystem_path__List__List(this: *mut std_filesystem_path__List);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path5_ListC1ERKS2_"]
    pub fn std_filesystem_path__List__List1(
        this: *mut std_filesystem_path__List,
        arg1: *const std_filesystem_path__List,
    );
}
impl std_filesystem_path__List {
    #[inline]
    pub unsafe fn type_(&mut self, arg1: std_filesystem_path__Type) {
        std_filesystem_path__List_type(self, arg1)
    }
    #[inline]
    pub unsafe fn size(&self) -> ::std::os::raw::c_int {
        std_filesystem_path__List_size(self)
    }
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        std_filesystem_path__List_empty(self)
    }
    #[inline]
    pub unsafe fn clear(&mut self) {
        std_filesystem_path__List_clear(self)
    }
    #[inline]
    pub unsafe fn capacity(&self) -> ::std::os::raw::c_int {
        std_filesystem_path__List_capacity(self)
    }
    #[inline]
    pub unsafe fn reserve(&mut self, arg1: ::std::os::raw::c_int, arg2: bool) {
        std_filesystem_path__List_reserve(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn begin(&mut self) -> std_filesystem_path__List_iterator {
        std_filesystem_path__List_begin(self)
    }
    #[inline]
    pub unsafe fn end(&mut self) -> std_filesystem_path__List_iterator {
        std_filesystem_path__List_end(self)
    }
    #[inline]
    pub unsafe fn begin1(&self) -> std_filesystem_path__List_const_iterator {
        std_filesystem_path__List_begin1(self)
    }
    #[inline]
    pub unsafe fn end1(&self) -> std_filesystem_path__List_const_iterator {
        std_filesystem_path__List_end1(self)
    }
    #[inline]
    pub unsafe fn front(&mut self) -> *mut std_filesystem_path__List_value_type {
        std_filesystem_path__List_front(self)
    }
    #[inline]
    pub unsafe fn back(&mut self) -> *mut std_filesystem_path__List_value_type {
        std_filesystem_path__List_back(self)
    }
    #[inline]
    pub unsafe fn front1(&self) -> *const std_filesystem_path__List_value_type {
        std_filesystem_path__List_front1(self)
    }
    #[inline]
    pub unsafe fn back1(&self) -> *const std_filesystem_path__List_value_type {
        std_filesystem_path__List_back1(self)
    }
    #[inline]
    pub unsafe fn pop_back(&mut self) {
        std_filesystem_path__List_pop_back(self)
    }
    #[inline]
    pub unsafe fn _M_erase_from(&mut self, __pos: std_filesystem_path__List_const_iterator) {
        std_filesystem_path__List__M_erase_from(self, __pos)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_filesystem_path__List__List(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_filesystem_path__List) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_filesystem_path__List__List1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_filesystem_path__Parser {
    _unused: [u8; 0],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_filesystem_path"][::std::mem::size_of::<std_filesystem_path>() - 40usize];
    ["Alignment of std_filesystem_path"][::std::mem::align_of::<std_filesystem_path>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path15remove_filenameEv"]
    pub fn std_filesystem_path_remove_filename(
        this: *mut std_filesystem_path,
    ) -> *mut std_filesystem_path;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path16replace_filenameERKS1_"]
    pub fn std_filesystem_path_replace_filename(
        this: *mut std_filesystem_path,
        __replacement: *const std_filesystem_path,
    ) -> *mut std_filesystem_path;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path17replace_extensionERKS1_"]
    pub fn std_filesystem_path_replace_extension(
        this: *mut std_filesystem_path,
        __replacement: *const std_filesystem_path,
    ) -> *mut std_filesystem_path;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path7compareERKS1_"]
    pub fn std_filesystem_path_compare(
        this: *const std_filesystem_path,
        __p: *const std_filesystem_path,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path7compareESt17basic_string_viewIwSt11char_traitsIwEE"]
    pub fn std_filesystem_path_compare1(
        this: *const std_filesystem_path,
        __s: __BindgenOpaqueArray<u64, 2usize>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path9root_nameEv"]
    pub fn std_filesystem_path_root_name(this: *const std_filesystem_path) -> std_filesystem_path;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path14root_directoryEv"]
    pub fn std_filesystem_path_root_directory(
        this: *const std_filesystem_path,
    ) -> std_filesystem_path;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path9root_pathEv"]
    pub fn std_filesystem_path_root_path(this: *const std_filesystem_path) -> std_filesystem_path;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path13relative_pathEv"]
    pub fn std_filesystem_path_relative_path(
        this: *const std_filesystem_path,
    ) -> std_filesystem_path;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path11parent_pathEv"]
    pub fn std_filesystem_path_parent_path(this: *const std_filesystem_path)
        -> std_filesystem_path;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path13has_root_nameEv"]
    pub fn std_filesystem_path_has_root_name(this: *const std_filesystem_path) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path18has_root_directoryEv"]
    pub fn std_filesystem_path_has_root_directory(this: *const std_filesystem_path) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path13has_root_pathEv"]
    pub fn std_filesystem_path_has_root_path(this: *const std_filesystem_path) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path17has_relative_pathEv"]
    pub fn std_filesystem_path_has_relative_path(this: *const std_filesystem_path) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path15has_parent_pathEv"]
    pub fn std_filesystem_path_has_parent_path(this: *const std_filesystem_path) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path12has_filenameEv"]
    pub fn std_filesystem_path_has_filename(this: *const std_filesystem_path) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path16lexically_normalEv"]
    pub fn std_filesystem_path_lexically_normal(
        this: *const std_filesystem_path,
    ) -> std_filesystem_path;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path18lexically_relativeERKS1_"]
    pub fn std_filesystem_path_lexically_relative(
        this: *const std_filesystem_path,
        base: *const std_filesystem_path,
    ) -> std_filesystem_path;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10filesystem7__cxx114path19lexically_proximateERKS1_"]
    pub fn std_filesystem_path_lexically_proximate(
        this: *const std_filesystem_path,
        base: *const std_filesystem_path,
    ) -> std_filesystem_path;
}
impl std_filesystem_path {
    #[inline]
    pub unsafe fn remove_filename(&mut self) -> *mut std_filesystem_path {
        std_filesystem_path_remove_filename(self)
    }
    #[inline]
    pub unsafe fn replace_filename(
        &mut self,
        __replacement: *const std_filesystem_path,
    ) -> *mut std_filesystem_path {
        std_filesystem_path_replace_filename(self, __replacement)
    }
    #[inline]
    pub unsafe fn replace_extension(
        &mut self,
        __replacement: *const std_filesystem_path,
    ) -> *mut std_filesystem_path {
        std_filesystem_path_replace_extension(self, __replacement)
    }
    #[inline]
    pub unsafe fn compare(&self, __p: *const std_filesystem_path) -> ::std::os::raw::c_int {
        std_filesystem_path_compare(self, __p)
    }
    #[inline]
    pub unsafe fn compare1(&self, __s: __BindgenOpaqueArray<u64, 2usize>) -> ::std::os::raw::c_int {
        std_filesystem_path_compare1(self, __s)
    }
    #[inline]
    pub unsafe fn root_name(&self) -> std_filesystem_path {
        std_filesystem_path_root_name(self)
    }
    #[inline]
    pub unsafe fn root_directory(&self) -> std_filesystem_path {
        std_filesystem_path_root_directory(self)
    }
    #[inline]
    pub unsafe fn root_path(&self) -> std_filesystem_path {
        std_filesystem_path_root_path(self)
    }
    #[inline]
    pub unsafe fn relative_path(&self) -> std_filesystem_path {
        std_filesystem_path_relative_path(self)
    }
    #[inline]
    pub unsafe fn parent_path(&self) -> std_filesystem_path {
        std_filesystem_path_parent_path(self)
    }
    #[inline]
    pub unsafe fn has_root_name(&self) -> bool {
        std_filesystem_path_has_root_name(self)
    }
    #[inline]
    pub unsafe fn has_root_directory(&self) -> bool {
        std_filesystem_path_has_root_directory(self)
    }
    #[inline]
    pub unsafe fn has_root_path(&self) -> bool {
        std_filesystem_path_has_root_path(self)
    }
    #[inline]
    pub unsafe fn has_relative_path(&self) -> bool {
        std_filesystem_path_has_relative_path(self)
    }
    #[inline]
    pub unsafe fn has_parent_path(&self) -> bool {
        std_filesystem_path_has_parent_path(self)
    }
    #[inline]
    pub unsafe fn has_filename(&self) -> bool {
        std_filesystem_path_has_filename(self)
    }
    #[inline]
    pub unsafe fn lexically_normal(&self) -> std_filesystem_path {
        std_filesystem_path_lexically_normal(self)
    }
    #[inline]
    pub unsafe fn lexically_relative(
        &self,
        base: *const std_filesystem_path,
    ) -> std_filesystem_path {
        std_filesystem_path_lexically_relative(self, base)
    }
    #[inline]
    pub unsafe fn lexically_proximate(
        &self,
        base: *const std_filesystem_path,
    ) -> std_filesystem_path {
        std_filesystem_path_lexically_proximate(self, base)
    }
}
pub const std_filesystem_path_preferred_separator: std_filesystem_path_value_type = 92;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_filesystem_path__Cmpt {
    pub _bindgen_opaque_blob: [u64; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_filesystem_path__Cmpt"]
        [::std::mem::size_of::<std_filesystem_path__Cmpt>() - 48usize];
    ["Alignment of std_filesystem_path__Cmpt"]
        [::std::mem::align_of::<std_filesystem_path__Cmpt>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem7__cxx114path5_CmptC1ESt17basic_string_viewIwSt11char_traitsIwEENS1_5_TypeEy"]
    pub fn std_filesystem_path__Cmpt__Cmpt(
        this: *mut std_filesystem_path__Cmpt,
        __s: __BindgenOpaqueArray<u64, 2usize>,
        __t: std_filesystem_path__Type,
        __pos: usize,
    );
}
impl std_filesystem_path__Cmpt {
    #[inline]
    pub unsafe fn new(
        __s: __BindgenOpaqueArray<u64, 2usize>,
        __t: std_filesystem_path__Type,
        __pos: usize,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_filesystem_path__Cmpt__Cmpt(__bindgen_tmp.as_mut_ptr(), __s, __t, __pos);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_filesystem_path__Codecvt {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_filesystem_path_iterator {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
pub type std_filesystem_path_iterator_difference_type = u64;
pub type std_filesystem_path_iterator_value_type = __BindgenOpaqueArray<u64, 5usize>;
pub type std_filesystem_path_iterator_reference = __BindgenOpaqueArray<u64, 5usize>;
pub type std_filesystem_path_iterator_pointer = u64;
pub type std_filesystem_path_iterator_iterator_category = u8;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_filesystem_path_iterator"]
        [::std::mem::size_of::<std_filesystem_path_iterator>() - 24usize];
    ["Alignment of std_filesystem_path_iterator"]
        [::std::mem::align_of::<std_filesystem_path_iterator>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr {
    pub _address: u8,
}
pub type std_unique_ptr__DeleterConstraint = u8;
pub type std_unique_ptr_pointer = u8;
pub type std_unique_ptr_element_type = u8;
pub type std_unique_ptr_deleter_type = u8;
pub type std_unique_ptr___safe_conversion_up = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unordered_map {
    pub _address: u8,
}
pub type std_unordered_map__Hashtable = u8;
pub type std_unordered_map_key_type = u8;
pub type std_unordered_map_value_type = u8;
pub type std_unordered_map_mapped_type = u8;
pub type std_unordered_map_hasher = u8;
pub type std_unordered_map_key_equal = u8;
pub type std_unordered_map_allocator_type = u8;
pub type std_unordered_map_pointer = u8;
pub type std_unordered_map_const_pointer = u8;
pub type std_unordered_map_reference = u8;
pub type std_unordered_map_const_reference = u8;
pub type std_unordered_map_iterator = u8;
pub type std_unordered_map_const_iterator = u8;
pub type std_unordered_map_local_iterator = u8;
pub type std_unordered_map_const_local_iterator = u8;
pub type std_unordered_map_size_type = u8;
pub type std_unordered_map_difference_type = u8;
pub type std_unordered_map_node_type = u8;
pub type std_unordered_map_insert_return_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Base = u8;
pub type std_vector__Tp_alloc_type = u8;
pub type std_vector__Alloc_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_size_type = u64;
pub type std_vector_difference_type = u64;
pub type std_vector_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector__Temporary_value {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Copy, Clone)]
pub union std_vector__Temporary_value__Storage {
    pub _bindgen_opaque_blob: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator {
    pub _address: u8,
}
pub type __gnu_cxx___normal_iterator___traits_type = u8;
pub type __gnu_cxx___normal_iterator___convertible_from = u8;
pub type __gnu_cxx___normal_iterator_iterator_type = u8;
pub type __gnu_cxx___normal_iterator_iterator_category = u8;
pub type __gnu_cxx___normal_iterator_value_type = u8;
pub type __gnu_cxx___normal_iterator_difference_type = u8;
pub type __gnu_cxx___normal_iterator_reference = u8;
pub type __gnu_cxx___normal_iterator_pointer = u8;
#[doc = " \\brief Base class typedef.\n \\sa PlainObjectBase"]
pub type Eigen_Matrix_Base = u8;
pub const Eigen_Matrix_Options: Eigen_Matrix__bindgen_ty_1 = 0;
pub type Eigen_Matrix__bindgen_ty_1 = i32;
pub type Eigen_Matrix_Scalar = u8;
pub type Eigen_Matrix_RealScalar = u8;
pub type Eigen_Matrix_CoeffReturnType = u8;
pub type Eigen_Matrix_Nested = u8;
pub type Eigen_Matrix_StorageKind = u8;
pub type Eigen_Matrix_StorageIndex = u8;
pub const Eigen_Matrix_CompileTimeTraits_RowsAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_ColsAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_Flags: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_SizeAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_MaxSizeAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_IsVectorAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub type Eigen_Matrix_CompileTimeTraits = i32;
pub type Eigen_Matrix_PacketScalar = u8;
pub type Eigen_Matrix_PlainObject = u8;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam Scalar_ Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam Rows_ Number of rows, or \\b Dynamic\n \\tparam Cols_ Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam Options_ A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam MaxRows_ Maximum number of rows. Defaults to \\a Rows_ (\\ref maxrows \"note\").\n \\tparam MaxCols_ Maximum number of columns. Defaults to \\a Cols_ (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows MaxRows_ and MaxCols_:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case MaxRows_ and MaxCols_\n are the dimensions of the original matrix, while Rows_ and Cols_ are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_MatrixXf = __BindgenOpaqueArray<u64, 3usize>;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam Scalar_ Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam Rows_ Number of rows, or \\b Dynamic\n \\tparam Cols_ Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam Options_ A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam MaxRows_ Maximum number of rows. Defaults to \\a Rows_ (\\ref maxrows \"note\").\n \\tparam MaxCols_ Maximum number of columns. Defaults to \\a Cols_ (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows MaxRows_ and MaxCols_:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case MaxRows_ and MaxCols_\n are the dimensions of the original matrix, while Rows_ and Cols_ are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type Eigen_VectorXf = __BindgenOpaqueArray<u64, 2usize>;
pub type Eigen_Block_Impl = u8;
pub type Eigen_Block_Base = u8;
pub type Eigen_Block_Scalar = u8;
pub type Eigen_Block_RealScalar = u8;
pub type Eigen_Block_CoeffReturnType = u8;
pub type Eigen_Block_Nested = u8;
pub type Eigen_Block_StorageKind = u8;
pub type Eigen_Block_StorageIndex = u8;
pub const Eigen_Block_CompileTimeTraits_RowsAtCompileTime: Eigen_Block_CompileTimeTraits = 0;
pub const Eigen_Block_CompileTimeTraits_ColsAtCompileTime: Eigen_Block_CompileTimeTraits = 0;
pub const Eigen_Block_CompileTimeTraits_Flags: Eigen_Block_CompileTimeTraits = 0;
pub const Eigen_Block_CompileTimeTraits_SizeAtCompileTime: Eigen_Block_CompileTimeTraits = 0;
pub const Eigen_Block_CompileTimeTraits_MaxSizeAtCompileTime: Eigen_Block_CompileTimeTraits = 0;
pub const Eigen_Block_CompileTimeTraits_IsVectorAtCompileTime: Eigen_Block_CompileTimeTraits = 0;
pub type Eigen_Block_CompileTimeTraits = i32;
pub type Eigen_Block_NestedExpression = u8;
#[repr(C)]
pub struct nam_activations_Activation__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nam_activations_Activation {
    pub vtable_: *const nam_activations_Activation__bindgen_vtable,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam11activations10Activation15using_fast_tanhE"]
    pub static mut nam_activations_Activation_using_fast_tanh: bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam11activations10Activation12_activationsB5cxx11E"]
    pub static mut nam_activations_Activation__activations: u8;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_activations_Activation"]
        [::std::mem::size_of::<nam_activations_Activation>() - 8usize];
    ["Alignment of nam_activations_Activation"]
        [::std::mem::align_of::<nam_activations_Activation>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam11activations10Activation14get_activationENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn nam_activations_Activation_get_activation(
        name: std_string,
    ) -> *mut nam_activations_Activation;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam11activations10Activation16enable_fast_tanhEv"]
    pub fn nam_activations_Activation_enable_fast_tanh();
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam11activations10Activation17disable_fast_tanhEv"]
    pub fn nam_activations_Activation_disable_fast_tanh();
}
impl nam_activations_Activation {
    #[inline]
    pub unsafe fn get_activation(name: std_string) -> *mut nam_activations_Activation {
        nam_activations_Activation_get_activation(name)
    }
    #[inline]
    pub unsafe fn enable_fast_tanh() {
        nam_activations_Activation_enable_fast_tanh()
    }
    #[inline]
    pub unsafe fn disable_fast_tanh() {
        nam_activations_Activation_disable_fast_tanh()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_activations_ActivationTanh {
    pub _base: nam_activations_Activation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_activations_ActivationTanh"]
        [::std::mem::size_of::<nam_activations_ActivationTanh>() - 8usize];
    ["Alignment of nam_activations_ActivationTanh"]
        [::std::mem::align_of::<nam_activations_ActivationTanh>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct nam_activations_ActivationHardTanh {
    pub _base: nam_activations_Activation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_activations_ActivationHardTanh"]
        [::std::mem::size_of::<nam_activations_ActivationHardTanh>() - 8usize];
    ["Alignment of nam_activations_ActivationHardTanh"]
        [::std::mem::align_of::<nam_activations_ActivationHardTanh>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct nam_activations_ActivationFastTanh {
    pub _base: nam_activations_Activation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_activations_ActivationFastTanh"]
        [::std::mem::size_of::<nam_activations_ActivationFastTanh>() - 8usize];
    ["Alignment of nam_activations_ActivationFastTanh"]
        [::std::mem::align_of::<nam_activations_ActivationFastTanh>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct nam_activations_ActivationReLU {
    pub _base: nam_activations_Activation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_activations_ActivationReLU"]
        [::std::mem::size_of::<nam_activations_ActivationReLU>() - 8usize];
    ["Alignment of nam_activations_ActivationReLU"]
        [::std::mem::align_of::<nam_activations_ActivationReLU>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct nam_activations_ActivationLeakyReLU {
    pub _base: nam_activations_Activation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_activations_ActivationLeakyReLU"]
        [::std::mem::size_of::<nam_activations_ActivationLeakyReLU>() - 8usize];
    ["Alignment of nam_activations_ActivationLeakyReLU"]
        [::std::mem::align_of::<nam_activations_ActivationLeakyReLU>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct nam_activations_ActivationSigmoid {
    pub _base: nam_activations_Activation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_activations_ActivationSigmoid"]
        [::std::mem::size_of::<nam_activations_ActivationSigmoid>() - 8usize];
    ["Alignment of nam_activations_ActivationSigmoid"]
        [::std::mem::align_of::<nam_activations_ActivationSigmoid>() - 8usize];
};
pub const nam_EArchitectures_kLinear: nam_EArchitectures = 0;
pub const nam_EArchitectures_kConvNet: nam_EArchitectures = 1;
pub const nam_EArchitectures_kLSTM: nam_EArchitectures = 2;
pub const nam_EArchitectures_kCatLSTM: nam_EArchitectures = 3;
pub const nam_EArchitectures_kWaveNet: nam_EArchitectures = 4;
pub const nam_EArchitectures_kCatWaveNet: nam_EArchitectures = 5;
pub const nam_EArchitectures_kNumModels: nam_EArchitectures = 6;
pub type nam_EArchitectures = ::std::os::raw::c_uint;
#[repr(C)]
pub struct nam_DSP__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nam_DSP {
    pub vtable_: *const nam_DSP__bindgen_vtable,
    mHasLoudness: bool,
    mLoudness: f64,
    mExpectedSampleRate: f64,
    mHaveExternalSampleRate: bool,
    mExternalSampleRate: f64,
    mMaxBufferSize: ::std::os::raw::c_int,
    mInputLevel: nam_DSP_Level,
    mOutputLevel: nam_DSP_Level,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nam_DSP_Level {
    pub haveLevel: bool,
    pub level: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_DSP_Level"][::std::mem::size_of::<nam_DSP_Level>() - 8usize];
    ["Alignment of nam_DSP_Level"][::std::mem::align_of::<nam_DSP_Level>() - 4usize];
    ["Offset of field: nam_DSP_Level::haveLevel"]
        [::std::mem::offset_of!(nam_DSP_Level, haveLevel) - 0usize];
    ["Offset of field: nam_DSP_Level::level"]
        [::std::mem::offset_of!(nam_DSP_Level, level) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_DSP"][::std::mem::size_of::<nam_DSP>() - 72usize];
    ["Alignment of nam_DSP"][::std::mem::align_of::<nam_DSP>() - 8usize];
    ["Offset of field: nam_DSP::mHasLoudness"]
        [::std::mem::offset_of!(nam_DSP, mHasLoudness) - 8usize];
    ["Offset of field: nam_DSP::mLoudness"][::std::mem::offset_of!(nam_DSP, mLoudness) - 16usize];
    ["Offset of field: nam_DSP::mExpectedSampleRate"]
        [::std::mem::offset_of!(nam_DSP, mExpectedSampleRate) - 24usize];
    ["Offset of field: nam_DSP::mHaveExternalSampleRate"]
        [::std::mem::offset_of!(nam_DSP, mHaveExternalSampleRate) - 32usize];
    ["Offset of field: nam_DSP::mExternalSampleRate"]
        [::std::mem::offset_of!(nam_DSP, mExternalSampleRate) - 40usize];
    ["Offset of field: nam_DSP::mMaxBufferSize"]
        [::std::mem::offset_of!(nam_DSP, mMaxBufferSize) - 48usize];
    ["Offset of field: nam_DSP::mInputLevel"]
        [::std::mem::offset_of!(nam_DSP, mInputLevel) - 52usize];
    ["Offset of field: nam_DSP::mOutputLevel"]
        [::std::mem::offset_of!(nam_DSP, mOutputLevel) - 60usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK3nam3DSP11GetLoudnessEv"]
    pub fn nam_DSP_GetLoudness(this: *const nam_DSP) -> f64;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam3DSP11SetLoudnessEd"]
    pub fn nam_DSP_SetLoudness(this: *mut nam_DSP, loudness: f64);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam3DSPC1Ed"]
    pub fn nam_DSP_DSP(this: *mut nam_DSP, expected_sample_rate: f64);
}
impl nam_DSP {
    #[inline]
    pub unsafe fn GetLoudness(&self) -> f64 {
        nam_DSP_GetLoudness(self)
    }
    #[inline]
    pub unsafe fn SetLoudness(&mut self, loudness: f64) {
        nam_DSP_SetLoudness(self, loudness)
    }
    #[inline]
    pub unsafe fn new(expected_sample_rate: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_DSP_DSP(__bindgen_tmp.as_mut_ptr(), expected_sample_rate);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam3DSP7prewarmEv"]
    pub fn nam_DSP_prewarm(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam3DSP7processEPfS1_i"]
    pub fn nam_DSP_process(
        this: *mut ::std::os::raw::c_void,
        input: *mut f32,
        output: *mut f32,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam3DSP5ResetEdi"]
    pub fn nam_DSP_Reset(
        this: *mut ::std::os::raw::c_void,
        sampleRate: f64,
        maxBufferSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam3DSP16SetMaxBufferSizeEi"]
    pub fn nam_DSP_SetMaxBufferSize(
        this: *mut ::std::os::raw::c_void,
        maxBufferSize: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct nam_Buffer {
    pub _bindgen_opaque_blob: [u64; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_Buffer"][::std::mem::size_of::<nam_Buffer>() - 128usize];
    ["Alignment of nam_Buffer"][::std::mem::align_of::<nam_Buffer>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam6Buffer22_advance_input_buffer_Ei"]
    pub fn nam_Buffer__advance_input_buffer_(
        this: *mut nam_Buffer,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam6Buffer20_set_receptive_fieldEii"]
    pub fn nam_Buffer__set_receptive_field(
        this: *mut nam_Buffer,
        new_receptive_field: ::std::os::raw::c_int,
        input_buffer_size: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam6Buffer20_set_receptive_fieldEi"]
    pub fn nam_Buffer__set_receptive_field1(
        this: *mut nam_Buffer,
        new_receptive_field: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam6Buffer19_reset_input_bufferEv"]
    pub fn nam_Buffer__reset_input_buffer(this: *mut nam_Buffer);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam6BufferC1Eid"]
    pub fn nam_Buffer_Buffer(
        this: *mut nam_Buffer,
        receptive_field: ::std::os::raw::c_int,
        expected_sample_rate: f64,
    );
}
impl nam_Buffer {
    #[inline]
    pub unsafe fn _advance_input_buffer_(&mut self, num_frames: ::std::os::raw::c_int) {
        nam_Buffer__advance_input_buffer_(self, num_frames)
    }
    #[inline]
    pub unsafe fn _set_receptive_field(
        &mut self,
        new_receptive_field: ::std::os::raw::c_int,
        input_buffer_size: ::std::os::raw::c_int,
    ) {
        nam_Buffer__set_receptive_field(self, new_receptive_field, input_buffer_size)
    }
    #[inline]
    pub unsafe fn _set_receptive_field1(&mut self, new_receptive_field: ::std::os::raw::c_int) {
        nam_Buffer__set_receptive_field1(self, new_receptive_field)
    }
    #[inline]
    pub unsafe fn _reset_input_buffer(&mut self) {
        nam_Buffer__reset_input_buffer(self)
    }
    #[inline]
    pub unsafe fn new(receptive_field: ::std::os::raw::c_int, expected_sample_rate: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_Buffer_Buffer(
            __bindgen_tmp.as_mut_ptr(),
            receptive_field,
            expected_sample_rate,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam6Buffer16_update_buffers_EPfi"]
    pub fn nam_Buffer__update_buffers_(
        this: *mut ::std::os::raw::c_void,
        input: *mut f32,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam6Buffer16_rewind_buffers_Ev"]
    pub fn nam_Buffer__rewind_buffers_(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nam_Linear {
    pub _base: nam_Buffer,
    _weight: Eigen_VectorXf,
    _bias: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_Linear"][::std::mem::size_of::<nam_Linear>() - 152usize];
    ["Alignment of nam_Linear"][::std::mem::align_of::<nam_Linear>() - 8usize];
    ["Offset of field: nam_Linear::_weight"]
        [::std::mem::offset_of!(nam_Linear, _weight) - 128usize];
    ["Offset of field: nam_Linear::_bias"][::std::mem::offset_of!(nam_Linear, _bias) - 144usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam6LinearC1EibRKSt6vectorIfSaIfEEd"]
    pub fn nam_Linear_Linear(
        this: *mut nam_Linear,
        receptive_field: ::std::os::raw::c_int,
        _bias: bool,
        weights: *const __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    );
}
impl nam_Linear {
    #[inline]
    pub unsafe fn new(
        receptive_field: ::std::os::raw::c_int,
        _bias: bool,
        weights: *const __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_Linear_Linear(
            __bindgen_tmp.as_mut_ptr(),
            receptive_field,
            _bias,
            weights,
            expected_sample_rate,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam6Linear7processEPfS1_i"]
    pub fn nam_Linear_process(
        this: *mut ::std::os::raw::c_void,
        input: *mut f32,
        output: *mut f32,
        num_frames: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_Conv1D {
    _weight: __BindgenOpaqueArray<u64, 3usize>,
    _bias: Eigen_VectorXf,
    _dilation: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_Conv1D"][::std::mem::size_of::<nam_Conv1D>() - 48usize];
    ["Alignment of nam_Conv1D"][::std::mem::align_of::<nam_Conv1D>() - 8usize];
    ["Offset of field: nam_Conv1D::_weight"][::std::mem::offset_of!(nam_Conv1D, _weight) - 0usize];
    ["Offset of field: nam_Conv1D::_bias"][::std::mem::offset_of!(nam_Conv1D, _bias) - 24usize];
    ["Offset of field: nam_Conv1D::_dilation"]
        [::std::mem::offset_of!(nam_Conv1D, _dilation) - 40usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam6Conv1D12set_weights_ERN9__gnu_cxx17__normal_iteratorIPfSt6vectorIfSaIfEEEE"]
    pub fn nam_Conv1D_set_weights_(this: *mut nam_Conv1D, weights: *mut u8);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam6Conv1D9set_size_Eiiibi"]
    pub fn nam_Conv1D_set_size_(
        this: *mut nam_Conv1D,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        do_bias: bool,
        _dilation: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam6Conv1D21set_size_and_weights_EiiiibRN9__gnu_cxx17__normal_iteratorIPfSt6vectorIfSaIfEEEE"]
    pub fn nam_Conv1D_set_size_and_weights_(
        this: *mut nam_Conv1D,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        _dilation: ::std::os::raw::c_int,
        do_bias: bool,
        weights: *mut u8,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK3nam6Conv1D8process_ERKN5Eigen6MatrixIfLin1ELin1ELi0ELin1ELin1EEERS3_lll"]
    pub fn nam_Conv1D_process_(
        this: *const nam_Conv1D,
        input: *const Eigen_MatrixXf,
        output: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        ncols: ::std::os::raw::c_long,
        j_start: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK3nam6Conv1D15get_num_weightsEv"]
    pub fn nam_Conv1D_get_num_weights(this: *const nam_Conv1D) -> ::std::os::raw::c_long;
}
impl nam_Conv1D {
    #[inline]
    pub unsafe fn set_weights_(&mut self, weights: *mut u8) {
        nam_Conv1D_set_weights_(self, weights)
    }
    #[inline]
    pub unsafe fn set_size_(
        &mut self,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        do_bias: bool,
        _dilation: ::std::os::raw::c_int,
    ) {
        nam_Conv1D_set_size_(
            self,
            in_channels,
            out_channels,
            kernel_size,
            do_bias,
            _dilation,
        )
    }
    #[inline]
    pub unsafe fn set_size_and_weights_(
        &mut self,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        _dilation: ::std::os::raw::c_int,
        do_bias: bool,
        weights: *mut u8,
    ) {
        nam_Conv1D_set_size_and_weights_(
            self,
            in_channels,
            out_channels,
            kernel_size,
            _dilation,
            do_bias,
            weights,
        )
    }
    #[inline]
    pub unsafe fn process_(
        &self,
        input: *const Eigen_MatrixXf,
        output: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        ncols: ::std::os::raw::c_long,
        j_start: ::std::os::raw::c_long,
    ) {
        nam_Conv1D_process_(self, input, output, i_start, ncols, j_start)
    }
    #[inline]
    pub unsafe fn get_num_weights(&self) -> ::std::os::raw::c_long {
        nam_Conv1D_get_num_weights(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nam_Conv1x1 {
    _weight: Eigen_MatrixXf,
    _bias: Eigen_VectorXf,
    _output: Eigen_MatrixXf,
    _do_bias: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_Conv1x1"][::std::mem::size_of::<nam_Conv1x1>() - 72usize];
    ["Alignment of nam_Conv1x1"][::std::mem::align_of::<nam_Conv1x1>() - 8usize];
    ["Offset of field: nam_Conv1x1::_weight"]
        [::std::mem::offset_of!(nam_Conv1x1, _weight) - 0usize];
    ["Offset of field: nam_Conv1x1::_bias"][::std::mem::offset_of!(nam_Conv1x1, _bias) - 24usize];
    ["Offset of field: nam_Conv1x1::_output"]
        [::std::mem::offset_of!(nam_Conv1x1, _output) - 40usize];
    ["Offset of field: nam_Conv1x1::_do_bias"]
        [::std::mem::offset_of!(nam_Conv1x1, _do_bias) - 64usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7Conv1x19GetOutputEi"]
    pub fn nam_Conv1x1_GetOutput(
        this: *mut nam_Conv1x1,
        num_frames: ::std::os::raw::c_int,
    ) -> __BindgenOpaqueArray<u64, 7usize>;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7Conv1x116SetMaxBufferSizeEi"]
    pub fn nam_Conv1x1_SetMaxBufferSize(
        this: *mut nam_Conv1x1,
        maxBufferSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7Conv1x112set_weights_ERN9__gnu_cxx17__normal_iteratorIPfSt6vectorIfSaIfEEEE"]
    pub fn nam_Conv1x1_set_weights_(this: *mut nam_Conv1x1, weights: *mut u8);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK3nam7Conv1x17processERKN5Eigen6MatrixIfLin1ELin1ELi0ELin1ELin1EEEi"]
    pub fn nam_Conv1x1_process(
        this: *const nam_Conv1x1,
        input: *const Eigen_MatrixXf,
        num_frames: ::std::os::raw::c_int,
    ) -> Eigen_MatrixXf;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7Conv1x18process_ERKN5Eigen6MatrixIfLin1ELin1ELi0ELin1ELin1EEEi"]
    pub fn nam_Conv1x1_process_(
        this: *mut nam_Conv1x1,
        input: *const Eigen_MatrixXf,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7Conv1x1C1Eiib"]
    pub fn nam_Conv1x1_Conv1x1(
        this: *mut nam_Conv1x1,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        _bias: bool,
    );
}
impl nam_Conv1x1 {
    #[inline]
    pub unsafe fn GetOutput(
        &mut self,
        num_frames: ::std::os::raw::c_int,
    ) -> __BindgenOpaqueArray<u64, 7usize> {
        nam_Conv1x1_GetOutput(self, num_frames)
    }
    #[inline]
    pub unsafe fn SetMaxBufferSize(&mut self, maxBufferSize: ::std::os::raw::c_int) {
        nam_Conv1x1_SetMaxBufferSize(self, maxBufferSize)
    }
    #[inline]
    pub unsafe fn set_weights_(&mut self, weights: *mut u8) {
        nam_Conv1x1_set_weights_(self, weights)
    }
    #[inline]
    pub unsafe fn process(
        &self,
        input: *const Eigen_MatrixXf,
        num_frames: ::std::os::raw::c_int,
    ) -> Eigen_MatrixXf {
        nam_Conv1x1_process(self, input, num_frames)
    }
    #[inline]
    pub unsafe fn process_(
        &mut self,
        input: *const Eigen_MatrixXf,
        num_frames: ::std::os::raw::c_int,
    ) {
        nam_Conv1x1_process_(self, input, num_frames)
    }
    #[inline]
    pub unsafe fn new(
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        _bias: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_Conv1x1_Conv1x1(__bindgen_tmp.as_mut_ptr(), in_channels, out_channels, _bias);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_dspData {
    pub version: std_string,
    pub architecture: std_string,
    pub config: nlohmann_json,
    pub metadata: nlohmann_json,
    pub weights: __BindgenOpaqueArray<u64, 3usize>,
    pub expected_sample_rate: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_dspData"][::std::mem::size_of::<nam_dspData>() - 128usize];
    ["Alignment of nam_dspData"][::std::mem::align_of::<nam_dspData>() - 8usize];
    ["Offset of field: nam_dspData::version"]
        [::std::mem::offset_of!(nam_dspData, version) - 0usize];
    ["Offset of field: nam_dspData::architecture"]
        [::std::mem::offset_of!(nam_dspData, architecture) - 32usize];
    ["Offset of field: nam_dspData::config"][::std::mem::offset_of!(nam_dspData, config) - 64usize];
    ["Offset of field: nam_dspData::metadata"]
        [::std::mem::offset_of!(nam_dspData, metadata) - 80usize];
    ["Offset of field: nam_dspData::weights"]
        [::std::mem::offset_of!(nam_dspData, weights) - 96usize];
    ["Offset of field: nam_dspData::expected_sample_rate"]
        [::std::mem::offset_of!(nam_dspData, expected_sample_rate) - 120usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam21verify_config_versionENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn nam_verify_config_version(version: std_string);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7get_dspENSt10filesystem7__cxx114pathE"]
    pub fn nam_get_dsp(model_file: std_filesystem_path) -> u64;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7get_dspENSt10filesystem7__cxx114pathERNS_7dspDataE"]
    pub fn nam_get_dsp1(model_file: std_filesystem_path, returnedConfig: *mut nam_dspData) -> u64;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7get_dspERNS_7dspDataE"]
    pub fn nam_get_dsp2(conf: *mut nam_dspData) -> u64;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam14get_dsp_legacyENSt10filesystem7__cxx114pathE"]
    pub fn nam_get_dsp_legacy(dirname: std_filesystem_path) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nam_convnet_BatchNorm {
    scale: Eigen_VectorXf,
    loc: Eigen_VectorXf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_convnet_BatchNorm"][::std::mem::size_of::<nam_convnet_BatchNorm>() - 32usize];
    ["Alignment of nam_convnet_BatchNorm"]
        [::std::mem::align_of::<nam_convnet_BatchNorm>() - 8usize];
    ["Offset of field: nam_convnet_BatchNorm::scale"]
        [::std::mem::offset_of!(nam_convnet_BatchNorm, scale) - 0usize];
    ["Offset of field: nam_convnet_BatchNorm::loc"]
        [::std::mem::offset_of!(nam_convnet_BatchNorm, loc) - 16usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK3nam7convnet9BatchNorm8process_ERN5Eigen6MatrixIfLin1ELin1ELi0ELin1ELin1EEEll"]
    pub fn nam_convnet_BatchNorm_process_(
        this: *const nam_convnet_BatchNorm,
        input: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        i_end: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7convnet9BatchNormC1EiRN9__gnu_cxx17__normal_iteratorIPfSt6vectorIfSaIfEEEE"]
    pub fn nam_convnet_BatchNorm_BatchNorm(
        this: *mut nam_convnet_BatchNorm,
        dim: ::std::os::raw::c_int,
        weights: *mut u8,
    );
}
impl nam_convnet_BatchNorm {
    #[inline]
    pub unsafe fn process_(
        &self,
        input: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        i_end: ::std::os::raw::c_long,
    ) {
        nam_convnet_BatchNorm_process_(self, input, i_start, i_end)
    }
    #[inline]
    pub unsafe fn new(dim: ::std::os::raw::c_int, weights: *mut u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_convnet_BatchNorm_BatchNorm(__bindgen_tmp.as_mut_ptr(), dim, weights);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_convnet_ConvNetBlock {
    pub conv: nam_Conv1D,
    batchnorm: nam_convnet_BatchNorm,
    _batchnorm: bool,
    activation: *mut nam_activations_Activation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_convnet_ConvNetBlock"]
        [::std::mem::size_of::<nam_convnet_ConvNetBlock>() - 96usize];
    ["Alignment of nam_convnet_ConvNetBlock"]
        [::std::mem::align_of::<nam_convnet_ConvNetBlock>() - 8usize];
    ["Offset of field: nam_convnet_ConvNetBlock::conv"]
        [::std::mem::offset_of!(nam_convnet_ConvNetBlock, conv) - 0usize];
    ["Offset of field: nam_convnet_ConvNetBlock::batchnorm"]
        [::std::mem::offset_of!(nam_convnet_ConvNetBlock, batchnorm) - 48usize];
    ["Offset of field: nam_convnet_ConvNetBlock::_batchnorm"]
        [::std::mem::offset_of!(nam_convnet_ConvNetBlock, _batchnorm) - 80usize];
    ["Offset of field: nam_convnet_ConvNetBlock::activation"]
        [::std::mem::offset_of!(nam_convnet_ConvNetBlock, activation) - 88usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7convnet12ConvNetBlock12set_weights_EiiibNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERN9__gnu_cxx17__normal_iteratorIPfSt6vectorIfSaIfEEEE"]
    pub fn nam_convnet_ConvNetBlock_set_weights_(
        this: *mut nam_convnet_ConvNetBlock,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        _dilation: ::std::os::raw::c_int,
        batchnorm: bool,
        activation: std_string,
        weights: *mut u8,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK3nam7convnet12ConvNetBlock8process_ERKN5Eigen6MatrixIfLin1ELin1ELi0ELin1ELin1EEERS4_ll"]
    pub fn nam_convnet_ConvNetBlock_process_(
        this: *const nam_convnet_ConvNetBlock,
        input: *const Eigen_MatrixXf,
        output: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        i_end: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK3nam7convnet12ConvNetBlock16get_out_channelsEv"]
    pub fn nam_convnet_ConvNetBlock_get_out_channels(
        this: *const nam_convnet_ConvNetBlock,
    ) -> ::std::os::raw::c_long;
}
impl nam_convnet_ConvNetBlock {
    #[inline]
    pub unsafe fn set_weights_(
        &mut self,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        _dilation: ::std::os::raw::c_int,
        batchnorm: bool,
        activation: std_string,
        weights: *mut u8,
    ) {
        nam_convnet_ConvNetBlock_set_weights_(
            self,
            in_channels,
            out_channels,
            _dilation,
            batchnorm,
            activation,
            weights,
        )
    }
    #[inline]
    pub unsafe fn process_(
        &self,
        input: *const Eigen_MatrixXf,
        output: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        i_end: ::std::os::raw::c_long,
    ) {
        nam_convnet_ConvNetBlock_process_(self, input, output, i_start, i_end)
    }
    #[inline]
    pub unsafe fn get_out_channels(&self) -> ::std::os::raw::c_long {
        nam_convnet_ConvNetBlock_get_out_channels(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nam_convnet__Head {
    _weight: Eigen_VectorXf,
    _bias: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_convnet__Head"][::std::mem::size_of::<nam_convnet__Head>() - 24usize];
    ["Alignment of nam_convnet__Head"][::std::mem::align_of::<nam_convnet__Head>() - 8usize];
    ["Offset of field: nam_convnet__Head::_weight"]
        [::std::mem::offset_of!(nam_convnet__Head, _weight) - 0usize];
    ["Offset of field: nam_convnet__Head::_bias"]
        [::std::mem::offset_of!(nam_convnet__Head, _bias) - 16usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK3nam7convnet5_Head8process_ERKN5Eigen6MatrixIfLin1ELin1ELi0ELin1ELin1EEERNS3_IfLin1ELi1ELi0ELin1ELi1EEEll"]
    pub fn nam_convnet__Head_process_(
        this: *const nam_convnet__Head,
        input: *const Eigen_MatrixXf,
        output: *mut Eigen_VectorXf,
        i_start: ::std::os::raw::c_long,
        i_end: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7convnet5_HeadC1EiRN9__gnu_cxx17__normal_iteratorIPfSt6vectorIfSaIfEEEE"]
    pub fn nam_convnet__Head__Head(
        this: *mut nam_convnet__Head,
        channels: ::std::os::raw::c_int,
        weights: *mut u8,
    );
}
impl nam_convnet__Head {
    #[inline]
    pub unsafe fn process_(
        &self,
        input: *const Eigen_MatrixXf,
        output: *mut Eigen_VectorXf,
        i_start: ::std::os::raw::c_long,
        i_end: ::std::os::raw::c_long,
    ) {
        nam_convnet__Head_process_(self, input, output, i_start, i_end)
    }
    #[inline]
    pub unsafe fn new(channels: ::std::os::raw::c_int, weights: *mut u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_convnet__Head__Head(__bindgen_tmp.as_mut_ptr(), channels, weights);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_convnet_ConvNet {
    pub _base: nam_Buffer,
    _blocks: __BindgenOpaqueArray<u64, 3usize>,
    _block_vals: __BindgenOpaqueArray<u64, 3usize>,
    _head_output: Eigen_VectorXf,
    _head: nam_convnet__Head,
    mPrewarmSamples: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_convnet_ConvNet"][::std::mem::size_of::<nam_convnet_ConvNet>() - 224usize];
    ["Alignment of nam_convnet_ConvNet"][::std::mem::align_of::<nam_convnet_ConvNet>() - 8usize];
    ["Offset of field: nam_convnet_ConvNet::_blocks"]
        [::std::mem::offset_of!(nam_convnet_ConvNet, _blocks) - 128usize];
    ["Offset of field: nam_convnet_ConvNet::_block_vals"]
        [::std::mem::offset_of!(nam_convnet_ConvNet, _block_vals) - 152usize];
    ["Offset of field: nam_convnet_ConvNet::_head_output"]
        [::std::mem::offset_of!(nam_convnet_ConvNet, _head_output) - 176usize];
    ["Offset of field: nam_convnet_ConvNet::_head"]
        [::std::mem::offset_of!(nam_convnet_ConvNet, _head) - 192usize];
    ["Offset of field: nam_convnet_ConvNet::mPrewarmSamples"]
        [::std::mem::offset_of!(nam_convnet_ConvNet, mPrewarmSamples) - 216usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7convnet7ConvNet15_verify_weightsEiRKSt6vectorIiSaIiEEby"]
    pub fn nam_convnet_ConvNet__verify_weights(
        this: *mut nam_convnet_ConvNet,
        channels: ::std::os::raw::c_int,
        dilations: *const __BindgenOpaqueArray<u64, 3usize>,
        batchnorm: bool,
        actual_weights: usize,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7convnet7ConvNetC1EiRKSt6vectorIiSaIiEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERS2_IfSaIfEEd"]
    pub fn nam_convnet_ConvNet_ConvNet(
        this: *mut nam_convnet_ConvNet,
        channels: ::std::os::raw::c_int,
        dilations: *const __BindgenOpaqueArray<u64, 3usize>,
        batchnorm: bool,
        activation: std_string,
        weights: *mut __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    );
}
impl nam_convnet_ConvNet {
    #[inline]
    pub unsafe fn _verify_weights(
        &mut self,
        channels: ::std::os::raw::c_int,
        dilations: *const __BindgenOpaqueArray<u64, 3usize>,
        batchnorm: bool,
        actual_weights: usize,
    ) {
        nam_convnet_ConvNet__verify_weights(self, channels, dilations, batchnorm, actual_weights)
    }
    #[inline]
    pub unsafe fn new(
        channels: ::std::os::raw::c_int,
        dilations: *const __BindgenOpaqueArray<u64, 3usize>,
        batchnorm: bool,
        activation: std_string,
        weights: *mut __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_convnet_ConvNet_ConvNet(
            __bindgen_tmp.as_mut_ptr(),
            channels,
            dilations,
            batchnorm,
            activation,
            weights,
            expected_sample_rate,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7convnet7ConvNet7processEPfS2_i"]
    pub fn nam_convnet_ConvNet_process(
        this: *mut ::std::os::raw::c_void,
        input: *mut f32,
        output: *mut f32,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7convnet7ConvNet16_update_buffers_EPfi"]
    pub fn nam_convnet_ConvNet__update_buffers_(
        this: *mut ::std::os::raw::c_void,
        input: *mut f32,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7convnet7ConvNet16_rewind_buffers_Ev"]
    pub fn nam_convnet_ConvNet__rewind_buffers_(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nam_lstm_LSTMCell {
    _w: Eigen_MatrixXf,
    _b: Eigen_VectorXf,
    _xh: Eigen_VectorXf,
    _ifgo: Eigen_VectorXf,
    _c: Eigen_VectorXf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_lstm_LSTMCell"][::std::mem::size_of::<nam_lstm_LSTMCell>() - 88usize];
    ["Alignment of nam_lstm_LSTMCell"][::std::mem::align_of::<nam_lstm_LSTMCell>() - 8usize];
    ["Offset of field: nam_lstm_LSTMCell::_w"]
        [::std::mem::offset_of!(nam_lstm_LSTMCell, _w) - 0usize];
    ["Offset of field: nam_lstm_LSTMCell::_b"]
        [::std::mem::offset_of!(nam_lstm_LSTMCell, _b) - 24usize];
    ["Offset of field: nam_lstm_LSTMCell::_xh"]
        [::std::mem::offset_of!(nam_lstm_LSTMCell, _xh) - 40usize];
    ["Offset of field: nam_lstm_LSTMCell::_ifgo"]
        [::std::mem::offset_of!(nam_lstm_LSTMCell, _ifgo) - 56usize];
    ["Offset of field: nam_lstm_LSTMCell::_c"]
        [::std::mem::offset_of!(nam_lstm_LSTMCell, _c) - 72usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam4lstm8LSTMCell8process_ERKN5Eigen6MatrixIfLin1ELi1ELi0ELin1ELi1EEE"]
    pub fn nam_lstm_LSTMCell_process_(this: *mut nam_lstm_LSTMCell, x: *const Eigen_VectorXf);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam4lstm8LSTMCellC1EiiRN9__gnu_cxx17__normal_iteratorIPfSt6vectorIfSaIfEEEE"]
    pub fn nam_lstm_LSTMCell_LSTMCell(
        this: *mut nam_lstm_LSTMCell,
        input_size: ::std::os::raw::c_int,
        hidden_size: ::std::os::raw::c_int,
        weights: *mut u8,
    );
}
impl nam_lstm_LSTMCell {
    #[inline]
    pub unsafe fn process_(&mut self, x: *const Eigen_VectorXf) {
        nam_lstm_LSTMCell_process_(self, x)
    }
    #[inline]
    pub unsafe fn new(
        input_size: ::std::os::raw::c_int,
        hidden_size: ::std::os::raw::c_int,
        weights: *mut u8,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_lstm_LSTMCell_LSTMCell(__bindgen_tmp.as_mut_ptr(), input_size, hidden_size, weights);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_lstm_LSTM {
    pub _base: nam_DSP,
    _head_weight: Eigen_VectorXf,
    _head_bias: f32,
    _layers: __BindgenOpaqueArray<u64, 3usize>,
    _input: Eigen_VectorXf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_lstm_LSTM"][::std::mem::size_of::<nam_lstm_LSTM>() - 136usize];
    ["Alignment of nam_lstm_LSTM"][::std::mem::align_of::<nam_lstm_LSTM>() - 8usize];
    ["Offset of field: nam_lstm_LSTM::_head_weight"]
        [::std::mem::offset_of!(nam_lstm_LSTM, _head_weight) - 72usize];
    ["Offset of field: nam_lstm_LSTM::_head_bias"]
        [::std::mem::offset_of!(nam_lstm_LSTM, _head_bias) - 88usize];
    ["Offset of field: nam_lstm_LSTM::_layers"]
        [::std::mem::offset_of!(nam_lstm_LSTM, _layers) - 96usize];
    ["Offset of field: nam_lstm_LSTM::_input"]
        [::std::mem::offset_of!(nam_lstm_LSTM, _input) - 120usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam4lstm4LSTM15_process_sampleEf"]
    pub fn nam_lstm_LSTM__process_sample(this: *mut nam_lstm_LSTM, x: f32) -> f32;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam4lstm4LSTMC1EiiiRSt6vectorIfSaIfEEd"]
    pub fn nam_lstm_LSTM_LSTM(
        this: *mut nam_lstm_LSTM,
        num_layers: ::std::os::raw::c_int,
        input_size: ::std::os::raw::c_int,
        hidden_size: ::std::os::raw::c_int,
        weights: *mut __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    );
}
impl nam_lstm_LSTM {
    #[inline]
    pub unsafe fn _process_sample(&mut self, x: f32) -> f32 {
        nam_lstm_LSTM__process_sample(self, x)
    }
    #[inline]
    pub unsafe fn new(
        num_layers: ::std::os::raw::c_int,
        input_size: ::std::os::raw::c_int,
        hidden_size: ::std::os::raw::c_int,
        weights: *mut __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_lstm_LSTM_LSTM(
            __bindgen_tmp.as_mut_ptr(),
            num_layers,
            input_size,
            hidden_size,
            weights,
            expected_sample_rate,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam4lstm4LSTM14PrewarmSamplesEv"]
    pub fn nam_lstm_LSTM_PrewarmSamples(this: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam4lstm4LSTM7processEPfS2_i"]
    pub fn nam_lstm_LSTM_process(
        this: *mut ::std::os::raw::c_void,
        input: *mut f32,
        output: *mut f32,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam4util9lowercaseERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn nam_util_lowercase(s: *const std_string) -> std_string;
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_wavenet__DilatedConv {
    pub _base: nam_Conv1D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_wavenet__DilatedConv"]
        [::std::mem::size_of::<nam_wavenet__DilatedConv>() - 48usize];
    ["Alignment of nam_wavenet__DilatedConv"]
        [::std::mem::align_of::<nam_wavenet__DilatedConv>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet12_DilatedConvC1Eiiiii"]
    pub fn nam_wavenet__DilatedConv__DilatedConv(
        this: *mut nam_wavenet__DilatedConv,
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        bias: ::std::os::raw::c_int,
        dilation: ::std::os::raw::c_int,
    );
}
impl nam_wavenet__DilatedConv {
    #[inline]
    pub unsafe fn new(
        in_channels: ::std::os::raw::c_int,
        out_channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        bias: ::std::os::raw::c_int,
        dilation: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_wavenet__DilatedConv__DilatedConv(
            __bindgen_tmp.as_mut_ptr(),
            in_channels,
            out_channels,
            kernel_size,
            bias,
            dilation,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_wavenet__Layer {
    _conv: nam_wavenet__DilatedConv,
    _input_mixin: nam_Conv1x1,
    _1x1: nam_Conv1x1,
    _z: Eigen_MatrixXf,
    _activation: *mut nam_activations_Activation,
    _gated: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_wavenet__Layer"][::std::mem::size_of::<nam_wavenet__Layer>() - 232usize];
    ["Alignment of nam_wavenet__Layer"][::std::mem::align_of::<nam_wavenet__Layer>() - 8usize];
    ["Offset of field: nam_wavenet__Layer::_conv"]
        [::std::mem::offset_of!(nam_wavenet__Layer, _conv) - 0usize];
    ["Offset of field: nam_wavenet__Layer::_input_mixin"]
        [::std::mem::offset_of!(nam_wavenet__Layer, _input_mixin) - 48usize];
    ["Offset of field: nam_wavenet__Layer::_1x1"]
        [::std::mem::offset_of!(nam_wavenet__Layer, _1x1) - 120usize];
    ["Offset of field: nam_wavenet__Layer::_z"]
        [::std::mem::offset_of!(nam_wavenet__Layer, _z) - 192usize];
    ["Offset of field: nam_wavenet__Layer::_activation"]
        [::std::mem::offset_of!(nam_wavenet__Layer, _activation) - 216usize];
    ["Offset of field: nam_wavenet__Layer::_gated"]
        [::std::mem::offset_of!(nam_wavenet__Layer, _gated) - 224usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet6_Layer16SetMaxBufferSizeEi"]
    pub fn nam_wavenet__Layer_SetMaxBufferSize(
        this: *mut nam_wavenet__Layer,
        maxBufferSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet6_Layer12set_weights_ERN9__gnu_cxx17__normal_iteratorIPfSt6vectorIfSaIfEEEE"]
    pub fn nam_wavenet__Layer_set_weights_(this: *mut nam_wavenet__Layer, weights: *mut u8);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet6_Layer8process_ERKN5Eigen6MatrixIfLin1ELin1ELi0ELin1ELin1EEES6_RS4_S7_lli"]
    pub fn nam_wavenet__Layer_process_(
        this: *mut nam_wavenet__Layer,
        input: *const Eigen_MatrixXf,
        condition: *const Eigen_MatrixXf,
        head_input: *mut Eigen_MatrixXf,
        output: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        j_start: ::std::os::raw::c_long,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet6_Layer15set_num_frames_El"]
    pub fn nam_wavenet__Layer_set_num_frames_(
        this: *mut nam_wavenet__Layer,
        num_frames: ::std::os::raw::c_long,
    );
}
impl nam_wavenet__Layer {
    #[inline]
    pub unsafe fn SetMaxBufferSize(&mut self, maxBufferSize: ::std::os::raw::c_int) {
        nam_wavenet__Layer_SetMaxBufferSize(self, maxBufferSize)
    }
    #[inline]
    pub unsafe fn set_weights_(&mut self, weights: *mut u8) {
        nam_wavenet__Layer_set_weights_(self, weights)
    }
    #[inline]
    pub unsafe fn process_(
        &mut self,
        input: *const Eigen_MatrixXf,
        condition: *const Eigen_MatrixXf,
        head_input: *mut Eigen_MatrixXf,
        output: *mut Eigen_MatrixXf,
        i_start: ::std::os::raw::c_long,
        j_start: ::std::os::raw::c_long,
        num_frames: ::std::os::raw::c_int,
    ) {
        nam_wavenet__Layer_process_(
            self, input, condition, head_input, output, i_start, j_start, num_frames,
        )
    }
    #[inline]
    pub unsafe fn set_num_frames_(&mut self, num_frames: ::std::os::raw::c_long) {
        nam_wavenet__Layer_set_num_frames_(self, num_frames)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_wavenet_LayerArrayParams {
    pub input_size: ::std::os::raw::c_int,
    pub condition_size: ::std::os::raw::c_int,
    pub head_size: ::std::os::raw::c_int,
    pub channels: ::std::os::raw::c_int,
    pub kernel_size: ::std::os::raw::c_int,
    pub dilations: __BindgenOpaqueArray<u64, 3usize>,
    pub activation: std_string,
    pub gated: bool,
    pub head_bias: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_wavenet_LayerArrayParams"]
        [::std::mem::size_of::<nam_wavenet_LayerArrayParams>() - 88usize];
    ["Alignment of nam_wavenet_LayerArrayParams"]
        [::std::mem::align_of::<nam_wavenet_LayerArrayParams>() - 8usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::input_size"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, input_size) - 0usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::condition_size"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, condition_size) - 4usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::head_size"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, head_size) - 8usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::channels"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, channels) - 12usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::kernel_size"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, kernel_size) - 16usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::dilations"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, dilations) - 24usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::activation"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, activation) - 48usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::gated"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, gated) - 80usize];
    ["Offset of field: nam_wavenet_LayerArrayParams::head_bias"]
        [::std::mem::offset_of!(nam_wavenet_LayerArrayParams, head_bias) - 81usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct nam_wavenet__LayerArray {
    _buffer_start: ::std::os::raw::c_long,
    _rechannel: nam_Conv1x1,
    _layer_buffers: __BindgenOpaqueArray<u64, 3usize>,
    _layers: __BindgenOpaqueArray<u64, 3usize>,
    _head_rechannel: nam_Conv1x1,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_wavenet__LayerArray"]
        [::std::mem::size_of::<nam_wavenet__LayerArray>() - 200usize];
    ["Alignment of nam_wavenet__LayerArray"]
        [::std::mem::align_of::<nam_wavenet__LayerArray>() - 8usize];
    ["Offset of field: nam_wavenet__LayerArray::_buffer_start"]
        [::std::mem::offset_of!(nam_wavenet__LayerArray, _buffer_start) - 0usize];
    ["Offset of field: nam_wavenet__LayerArray::_rechannel"]
        [::std::mem::offset_of!(nam_wavenet__LayerArray, _rechannel) - 8usize];
    ["Offset of field: nam_wavenet__LayerArray::_layer_buffers"]
        [::std::mem::offset_of!(nam_wavenet__LayerArray, _layer_buffers) - 80usize];
    ["Offset of field: nam_wavenet__LayerArray::_layers"]
        [::std::mem::offset_of!(nam_wavenet__LayerArray, _layers) - 104usize];
    ["Offset of field: nam_wavenet__LayerArray::_head_rechannel"]
        [::std::mem::offset_of!(nam_wavenet__LayerArray, _head_rechannel) - 128usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet11_LayerArray16SetMaxBufferSizeEi"]
    pub fn nam_wavenet__LayerArray_SetMaxBufferSize(
        this: *mut nam_wavenet__LayerArray,
        maxBufferSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet11_LayerArray16advance_buffers_Ei"]
    pub fn nam_wavenet__LayerArray_advance_buffers_(
        this: *mut nam_wavenet__LayerArray,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet11_LayerArray19prepare_for_frames_El"]
    pub fn nam_wavenet__LayerArray_prepare_for_frames_(
        this: *mut nam_wavenet__LayerArray,
        num_frames: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet11_LayerArray8process_ERKN5Eigen6MatrixIfLin1ELin1ELi0ELin1ELin1EEES6_RS4_S7_S7_i"]
    pub fn nam_wavenet__LayerArray_process_(
        this: *mut nam_wavenet__LayerArray,
        layer_inputs: *const Eigen_MatrixXf,
        condition: *const Eigen_MatrixXf,
        layer_outputs: *mut Eigen_MatrixXf,
        head_inputs: *mut Eigen_MatrixXf,
        head_outputs: *mut Eigen_MatrixXf,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet11_LayerArray15set_num_frames_El"]
    pub fn nam_wavenet__LayerArray_set_num_frames_(
        this: *mut nam_wavenet__LayerArray,
        num_frames: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet11_LayerArray12set_weights_ERN9__gnu_cxx17__normal_iteratorIPfSt6vectorIfSaIfEEEE"]
    pub fn nam_wavenet__LayerArray_set_weights_(this: *mut nam_wavenet__LayerArray, it: *mut u8);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK3nam7wavenet11_LayerArray19get_receptive_fieldEv"]
    pub fn nam_wavenet__LayerArray_get_receptive_field(
        this: *const nam_wavenet__LayerArray,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet11_LayerArrayC1EiiiiiRKSt6vectorIiSaIiEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEbb"]
    pub fn nam_wavenet__LayerArray__LayerArray(
        this: *mut nam_wavenet__LayerArray,
        input_size: ::std::os::raw::c_int,
        condition_size: ::std::os::raw::c_int,
        head_size: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        dilations: *const __BindgenOpaqueArray<u64, 3usize>,
        activation: std_string,
        gated: bool,
        head_bias: bool,
    );
}
impl nam_wavenet__LayerArray {
    #[inline]
    pub unsafe fn SetMaxBufferSize(&mut self, maxBufferSize: ::std::os::raw::c_int) {
        nam_wavenet__LayerArray_SetMaxBufferSize(self, maxBufferSize)
    }
    #[inline]
    pub unsafe fn advance_buffers_(&mut self, num_frames: ::std::os::raw::c_int) {
        nam_wavenet__LayerArray_advance_buffers_(self, num_frames)
    }
    #[inline]
    pub unsafe fn prepare_for_frames_(&mut self, num_frames: ::std::os::raw::c_long) {
        nam_wavenet__LayerArray_prepare_for_frames_(self, num_frames)
    }
    #[inline]
    pub unsafe fn process_(
        &mut self,
        layer_inputs: *const Eigen_MatrixXf,
        condition: *const Eigen_MatrixXf,
        layer_outputs: *mut Eigen_MatrixXf,
        head_inputs: *mut Eigen_MatrixXf,
        head_outputs: *mut Eigen_MatrixXf,
        num_frames: ::std::os::raw::c_int,
    ) {
        nam_wavenet__LayerArray_process_(
            self,
            layer_inputs,
            condition,
            layer_outputs,
            head_inputs,
            head_outputs,
            num_frames,
        )
    }
    #[inline]
    pub unsafe fn set_num_frames_(&mut self, num_frames: ::std::os::raw::c_long) {
        nam_wavenet__LayerArray_set_num_frames_(self, num_frames)
    }
    #[inline]
    pub unsafe fn set_weights_(&mut self, it: *mut u8) {
        nam_wavenet__LayerArray_set_weights_(self, it)
    }
    #[inline]
    pub unsafe fn get_receptive_field(&self) -> ::std::os::raw::c_long {
        nam_wavenet__LayerArray_get_receptive_field(self)
    }
    #[inline]
    pub unsafe fn new(
        input_size: ::std::os::raw::c_int,
        condition_size: ::std::os::raw::c_int,
        head_size: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        kernel_size: ::std::os::raw::c_int,
        dilations: *const __BindgenOpaqueArray<u64, 3usize>,
        activation: std_string,
        gated: bool,
        head_bias: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_wavenet__LayerArray__LayerArray(
            __bindgen_tmp.as_mut_ptr(),
            input_size,
            condition_size,
            head_size,
            channels,
            kernel_size,
            dilations,
            activation,
            gated,
            head_bias,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_wavenet__Head {
    _channels: ::std::os::raw::c_int,
    _layers: __BindgenOpaqueArray<u64, 3usize>,
    _head: nam_Conv1x1,
    _activation: *mut nam_activations_Activation,
    _buffers: __BindgenOpaqueArray<u64, 3usize>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_wavenet__Head"][::std::mem::size_of::<nam_wavenet__Head>() - 136usize];
    ["Alignment of nam_wavenet__Head"][::std::mem::align_of::<nam_wavenet__Head>() - 8usize];
    ["Offset of field: nam_wavenet__Head::_channels"]
        [::std::mem::offset_of!(nam_wavenet__Head, _channels) - 0usize];
    ["Offset of field: nam_wavenet__Head::_layers"]
        [::std::mem::offset_of!(nam_wavenet__Head, _layers) - 8usize];
    ["Offset of field: nam_wavenet__Head::_head"]
        [::std::mem::offset_of!(nam_wavenet__Head, _head) - 32usize];
    ["Offset of field: nam_wavenet__Head::_activation"]
        [::std::mem::offset_of!(nam_wavenet__Head, _activation) - 104usize];
    ["Offset of field: nam_wavenet__Head::_buffers"]
        [::std::mem::offset_of!(nam_wavenet__Head, _buffers) - 112usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet5_Head5ResetEdi"]
    pub fn nam_wavenet__Head_Reset(
        this: *mut nam_wavenet__Head,
        sampleRate: f64,
        maxBufferSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet5_Head12set_weights_ERN9__gnu_cxx17__normal_iteratorIPfSt6vectorIfSaIfEEEE"]
    pub fn nam_wavenet__Head_set_weights_(this: *mut nam_wavenet__Head, weights: *mut u8);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet5_Head8process_ERN5Eigen6MatrixIfLin1ELin1ELi0ELin1ELin1EEES5_"]
    pub fn nam_wavenet__Head_process_(
        this: *mut nam_wavenet__Head,
        inputs: *mut Eigen_MatrixXf,
        outputs: *mut Eigen_MatrixXf,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet5_Head15set_num_frames_El"]
    pub fn nam_wavenet__Head_set_num_frames_(
        this: *mut nam_wavenet__Head,
        num_frames: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet5_HeadC1EiiiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn nam_wavenet__Head__Head(
        this: *mut nam_wavenet__Head,
        input_size: ::std::os::raw::c_int,
        num_layers: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        activation: std_string,
    );
}
impl nam_wavenet__Head {
    #[inline]
    pub unsafe fn Reset(&mut self, sampleRate: f64, maxBufferSize: ::std::os::raw::c_int) {
        nam_wavenet__Head_Reset(self, sampleRate, maxBufferSize)
    }
    #[inline]
    pub unsafe fn set_weights_(&mut self, weights: *mut u8) {
        nam_wavenet__Head_set_weights_(self, weights)
    }
    #[inline]
    pub unsafe fn process_(&mut self, inputs: *mut Eigen_MatrixXf, outputs: *mut Eigen_MatrixXf) {
        nam_wavenet__Head_process_(self, inputs, outputs)
    }
    #[inline]
    pub unsafe fn set_num_frames_(&mut self, num_frames: ::std::os::raw::c_long) {
        nam_wavenet__Head_set_num_frames_(self, num_frames)
    }
    #[inline]
    pub unsafe fn new(
        input_size: ::std::os::raw::c_int,
        num_layers: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        activation: std_string,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_wavenet__Head__Head(
            __bindgen_tmp.as_mut_ptr(),
            input_size,
            num_layers,
            channels,
            activation,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nam_wavenet_WaveNet {
    pub _base: nam_DSP,
    _condition: Eigen_MatrixXf,
    _layer_arrays: __BindgenOpaqueArray<u64, 3usize>,
    _layer_array_outputs: __BindgenOpaqueArray<u64, 3usize>,
    _head_arrays: __BindgenOpaqueArray<u64, 3usize>,
    _head_scale: f32,
    _head_output: Eigen_MatrixXf,
    mPrewarmSamples: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nam_wavenet_WaveNet"][::std::mem::size_of::<nam_wavenet_WaveNet>() - 208usize];
    ["Alignment of nam_wavenet_WaveNet"][::std::mem::align_of::<nam_wavenet_WaveNet>() - 8usize];
    ["Offset of field: nam_wavenet_WaveNet::_condition"]
        [::std::mem::offset_of!(nam_wavenet_WaveNet, _condition) - 72usize];
    ["Offset of field: nam_wavenet_WaveNet::_layer_arrays"]
        [::std::mem::offset_of!(nam_wavenet_WaveNet, _layer_arrays) - 96usize];
    ["Offset of field: nam_wavenet_WaveNet::_layer_array_outputs"]
        [::std::mem::offset_of!(nam_wavenet_WaveNet, _layer_array_outputs) - 120usize];
    ["Offset of field: nam_wavenet_WaveNet::_head_arrays"]
        [::std::mem::offset_of!(nam_wavenet_WaveNet, _head_arrays) - 144usize];
    ["Offset of field: nam_wavenet_WaveNet::_head_scale"]
        [::std::mem::offset_of!(nam_wavenet_WaveNet, _head_scale) - 168usize];
    ["Offset of field: nam_wavenet_WaveNet::_head_output"]
        [::std::mem::offset_of!(nam_wavenet_WaveNet, _head_output) - 176usize];
    ["Offset of field: nam_wavenet_WaveNet::mPrewarmSamples"]
        [::std::mem::offset_of!(nam_wavenet_WaveNet, mPrewarmSamples) - 200usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet7WaveNet12set_weights_ERSt6vectorIfSaIfEE"]
    pub fn nam_wavenet_WaveNet_set_weights_(
        this: *mut nam_wavenet_WaveNet,
        weights: *mut __BindgenOpaqueArray<u64, 3usize>,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet7WaveNetC1ERKSt6vectorINS0_16LayerArrayParamsESaIS3_EEfbS2_IfSaIfEEd"]
    pub fn nam_wavenet_WaveNet_WaveNet(
        this: *mut nam_wavenet_WaveNet,
        layer_array_params: *const u8,
        head_scale: f32,
        with_head: bool,
        weights: __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    );
}
impl nam_wavenet_WaveNet {
    #[inline]
    pub unsafe fn set_weights_(&mut self, weights: *mut __BindgenOpaqueArray<u64, 3usize>) {
        nam_wavenet_WaveNet_set_weights_(self, weights)
    }
    #[inline]
    pub unsafe fn new(
        layer_array_params: *const u8,
        head_scale: f32,
        with_head: bool,
        weights: __BindgenOpaqueArray<u64, 3usize>,
        expected_sample_rate: f64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nam_wavenet_WaveNet_WaveNet(
            __bindgen_tmp.as_mut_ptr(),
            layer_array_params,
            head_scale,
            with_head,
            weights,
            expected_sample_rate,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet7WaveNet7processEPfS2_i"]
    pub fn nam_wavenet_WaveNet_process(
        this: *mut ::std::os::raw::c_void,
        input: *mut f32,
        output: *mut f32,
        num_frames: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet7WaveNet16SetMaxBufferSizeEi"]
    pub fn nam_wavenet_WaveNet_SetMaxBufferSize(
        this: *mut ::std::os::raw::c_void,
        maxBufferSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN3nam7wavenet7WaveNet20_set_condition_arrayEPfi"]
    pub fn nam_wavenet_WaveNet__set_condition_array(
        this: *mut ::std::os::raw::c_void,
        input: *mut f32,
        num_frames: ::std::os::raw::c_int,
    );
}
#[doc = "@brief default JSON class\n\nThis type is the default specialization of the @ref basic_json class which\nuses the standard template types.\n\n@since version 1.0.0"]
pub type nlohmann_json = __BindgenOpaqueArray<u64, 2usize>;
unsafe extern "C" {
    #[link_name = "\u{1}_Z24get_dsp_from_string_pathPKc"]
    pub fn get_dsp_from_string_path(str_: *const ::std::os::raw::c_char) -> u64;
}
unsafe extern "C" {
    #[link_name = "\u{1}_Z28get_dsp_expected_sample_ratePN3nam3DSPE"]
    pub fn get_dsp_expected_sample_rate(dsp: *mut nam_DSP) -> f64;
}
